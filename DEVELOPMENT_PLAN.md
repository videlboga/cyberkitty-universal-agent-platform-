# DEVELOPMENT_PLAN.md

# Архитектурный MVP-план (2024-05-22)

## Критические компоненты (оставить только их)
- Агенты (CRUD, связь с одним сценарием, MongoDB)
- Сценарии (CRUD, шаги — строго типизированные, MongoDB)
- TelegramPlugin (отправка сообщений, приём callback, строгая валидация)
- Работа с БД (MongoDB, репозитории, CRUD)
- Интеграция с OpenRouter (LLM, 1 endpoint)
- Универсальный curl-прокси (API для любых внешних запросов)

## Минимальные API-эндпоинты
- /api/v1/agents/ — CRUD агентов
- /api/v1/scenarios/ — CRUD сценариев
- /api/v1/agent-actions/{agent_id}/execute — запуск сценария для агента
- /api/v1/telegram/send — отправка сообщения в Telegram (для теста)
- /api/v1/llm/query — запрос к OpenRouter/OpenAI
- /api/v1/curl — универсальный curl-прокси

## Стратегия минимизации
- Всё, что не входит в этот план — временно закомментировать/отключить
- Каждый шаг сценария — отдельная Pydantic-модель
- TelegramPlugin: только явные параметры, только строгая валидация
- Логи — только в logs/, по типу событий
- Минимальный e2e-тест: создать сценарий → создать агента → запустить сценарий → получить сообщение в Telegram
- Любая новая фича — только если e2e зелёный

## Пошаговый план внедрения
1. Вынести все “лишние” плагины и шаги в комментарии
2. Ввести строгие Pydantic-модели для шагов сценария
3. Починить TelegramPlugin: только явные параметры, только строгая валидация
4. Сделать минимальный e2e-тест (можно ручной curl)
5. Покрыть этот путь автотестом
6. Только после этого — возвращать нужные интеграции по одной, с тестом на каждый путь

## 1. Общее Описание и Цели Проекта

Universal Agent Platform - платформа для создания, управления и запуска ИИ-агентов, способных выполнять сложные сценарии, интегрироваться с различными сервисами и взаимодействовать с пользователями через разные каналы.

**Основные цели рефакторинга и текущей разработки:**
- [ ] **Стабильность:** Достижение предсказуемой работы системы, устранение повторяющихся ошибок.
- [ ] **Упрощение:** Максимальное упрощение архитектуры и кода для облегчения понимания, поддержки и дальнейшей разработки.
- [ ] **Согласованность:** Обеспечение единообразия в коде, конфигурациях и потоках данных.
- [ ] **Тестируемость:** Улучшение покрытия тестами и упрощение написания новых тестов.
- [ ] **Следование CursorRules:** Приведение проекта в соответствие с заданными правилами разработки.

## 2. Ключевые Архитектурные Решения и Принципы

- **Логирование:**
    - Используется единый глобальный `logger = loguru.logger`, импортируемый в начале каждого файла.
    - Отказ от `self.logger` во всех классах.
    - Централизованная базовая настройка файловых логов (sinks) в `app/main.py` или `app/core/logging_config.py`.
    - Формат логов: JSON (где это применимо и настроено).
    - Директория для логов: `logs/` с разделением по типам (например, `errors.log`, `telegram_plugin.log`, `scenario_executor.log`).

- **Плагины (`app/plugins/`):**
    - Все плагины наследуются от `app.plugins.plugin_base.PluginBase`.
    - `PluginBase` определяет интерфейс (`initialize`, `register_step_handlers`, `healthcheck`).
    - `PluginManager` отвечает за загрузку и инициализацию плагинов, вызывая `await plugin.initialize(app_fastapi)`.
    - Зависимости (как `ScenarioExecutor` или FastAPI `app`) передаются в плагины через `initialize` или доступны через `app_fastapi.state`.

- **TelegramPlugin (`app/plugins/telegram_plugin.py`):**
    - Инстанс бота (`telegram.Bot`) получается через `self.app.bot` (где `self.app` - `telegram.ext.Application`) после `await self.app.initialize()`.
    - Отказ от `last_known_context_bot`.
    - Метод `_prepare_reply_markup` работает со структурой кнопок `List[List[Dict]]` (список рядов, каждый ряд - список кнопок).
    - Использует глобальный `logger` для логирования.

- **ScenarioExecutor (`app/core/scenario_executor.py`):**
    - Управляет контекстом выполнения сценария (`agent_id`, `user_id`, `chat_id`, `session_id`, etc.).
    - Контекст собирается на API-уровне (`app/api/runner.py`) и передается в executor.
    - Вызывает зарегистрированные обработчики шагов из плагинов, передавая им `step_data` и `context`.

- **Утилиты (`app/core/utils.py`):**
    - Общие вспомогательные функции (например, `_resolve_value_from_context`, `resolve_string_template`) централизованы здесь.

- **Конфигурация (`app/core/config.py`):**
    - Доступ к настройкам (токены, параметры и т.д.) осуществляется через объект `settings`.

## 3. Текущие Задачи и План Рефакторинга

### Этап 0: Немедленные Исправления (Выполнено)
- [x] Исправить `self.logger` на `logger` в `TelegramPlugin.edit_message_text`.
- [x] Глобальная проверка и замена `self.logger` на `logger` в `TelegramPlugin`.
- [x] Корректировка `TelegramPlugin._prepare_reply_markup` для работы с `List[List[Dict]]` и удаления `buttons_layout`.

### Этап 1: Стабилизация Ядра и Логирования
- **Текущий фокус: Убедиться, что логирование работает корректно и единообразно.**
- [x] **Задача 1.1:** Проверить и стандартизировать конфигурацию `loguru.logger.add()` для всех файловых логов (`telegram_plugin.log`, `scenario_executor.log`, `main_app.log` и т.д.) в одном центральном месте (например, `app/main.py` или `app/core/logging_config.py`). Удалить дублирующие `logger.add()` из плагинов, если они только настраивают те же самые файловые стоки.
    - *Ожидаемый результат:* Логи пишутся в нужные файлы с правильными настройками, нет конфликтов конфигурации.
- [x] **Задача 1.2 (Проверка):** Убедиться, что все плагины корректно наследуются от `app.plugins.plugin_base.PluginBase` и вызывают `super().__init__()`.
- [x] **Задача 1.3 (Проверка):** Убедиться, что `PluginManager.initialize_all_plugins()` корректно вызывает `await plugin.initialize(app_fastapi)` для всех плагинов.
- [x] **Задача 1.4 (Проверка):** Убедиться, что `TelegramPlugin.initialize` (включая `await self.app.initialize()` и `self.add_handlers()`) отрабатывает без ошибок, и `self.app.bot` становится доступен.
- [ ] **Задача 1.5:** Добиться чистых логов запуска Docker-контейнера `universal_agent_system-app-1` (отсутствие ошибок, только информационные сообщения об инициализации).

### Этап 2: Стабилизация TelegramPlugin (Отправка и обработка)
- **Цель:** Добиться надежной отправки сообщений и обработки callback'ов.
- [ ] **Задача 2.1:** Протестировать отправку первого сообщения сценария "опроса о пицце" через API `/execute`.
    - *Ожидаемый результат:* Сообщение с кнопками успешно отправляется в Telegram. Логи в `logs/telegram_plugin.log` подтверждают успешную отправку.
- [ ] **Задача 2.2:** Протестировать обработку `callback_query` (нажатие кнопки в Telegram).
    - *Ожидаемый результат:* Сценарий корректно возобновляется, переходит на следующий шаг. Соответствующие логи в `telegram_plugin.log` и `scenario_executor.log`.
- [ ] **Задача 2.3 (При необходимости):** Отладить `TelegramPlugin.on_callback_query` и `ScenarioExecutor.resume_scenario`.

### Этап 3: Утилиты и Поток Данных
- [ ] **Задача 3.1:** Перенести `_resolve_value_from_context` и `resolve_string_template` из `telegram_plugin.py` в `app/core/utils.py`. Обновить импорты.
- [ ] **Задача 3.2:** Проанализировать и, при необходимости, стандартизировать передачу ключевых идентификаторов (`agent_id`, `user_id`, `chat_id`, `session_id`) от API-слоя через `ScenarioExecutor` в плагины.

### Этап 4: Общий Рефакторинг и Упрощение (Долгосрочно)
- [ ] Оценить и упростить логику StateMachine.
- [ ] Провести ревизию всех плагинов на предмет соответствия `PluginBase` и общим принципам.
- [ ] Увеличить покрытие тестами.
- [ ] Обновить `README.md` с актуальной информацией.

## 4. Соглашения по Коду и Именованию (Будет дополняться)

- **Логгер:** Всегда использовать глобальный `logger` из `loguru`.
- **Кнопки Telegram:** `inline_keyboard` в сценариях и коде передается как `List[List[Dict[str, str]]]`.

## 5. Проблемные Зоны и Известные Ошибки (Будет дополняться)

- **Текущая проблема (22.05.2025):** Отправка сообщения из `TelegramPlugin` через `/execute` не работает, возвращается `_step_error`. Предполагаемая причина – проблемы с инициализацией бота или логированием, мешающие выполнению `send_message`.

## 6. Чек-лист для Модели ИИ (При работе с кодом)

- [ ] **Логгер:** Всегда используется глобальный `logger`, а не `self.logger`.
- [ ] **Telegram Кнопки:** При работе с `inline_keyboard` используется формат `List[List[Dict]]`.
- [ ] **Импорты:** Утилиты импортируются из `app.core.utils` (после их переноса).
- [ ] **Соответствие `DEVELOPMENT_PLAN.md`:** Предлагаемые изменения не противоречат зафиксированным архитектурным решениям и принципам.

---
*Этот документ будет регулярно обновляться по мере продвижения разработки.*
