# Руководство по разработке сценариев для Universal Agent Platform

## Введение

Это руководство описывает, как создавать и структурировать сценарии для Universal Agent Platform. Сценарии определяют логику взаимодействия с пользователем, вызовы плагинов (LLM, RAG, Telegram и др.) и управление потоком диалога.

Сценарии хранятся в формате JSON в директории `scenarios/`.

## 1. Общая структура сценария

Каждый сценарий представляет собой JSON-объект со следующими основными полями:

-   `scenario_id` (строка, обязательное): Уникальный идентификатор сценария. Используется для запуска и ссылок на сценарий.
-   `name` (строка, обязательное): Человекочитаемое имя сценария.
-   `description` (строка, опциональное): Краткое описание назначения сценария.
-   `version` (строка, опциональное): Версия сценария (например, "1.0").
-   `initial_context` (объект, опциональное): Начальные значения для контекста сценария. Эти значения будут доступны первому шагу.
-   `steps` (массив объектов, обязательное): Список шагов, определяющих логику сценария.

**Пример:**

```json
{
  "scenario_id": "example_greeting",
  "name": "Пример приветствия",
  "description": "Простой сценарий, который приветствует пользователя.",
  "version": "1.0",
  "initial_context": {
    "user_name": "Гость"
  },
  "steps": [
    // ... определения шагов ...
  ]
}
```

## 2. Структура шага (Step)

Каждый элемент в массиве `steps` представляет собой один шаг сценария. Шаги выполняются последовательно или в соответствии с логикой ветвления.

Общие поля для каждого шага:

-   `id` (строка, обязательное): Уникальный идентификатор шага в рамках сценария. Используется для переходов между шагами.
-   `type` (строка, обязательное): Тип шага, определяющий его поведение. Например, "message", "input", "llm_request".
-   `description` (строка, опциональное): Краткое описание назначения шага для разработчика.
-   `next_step_id` (строка, опциональное): `id` следующего шага, на который нужно перейти после успешного выполнения текущего. Не используется для шагов типа `branch` или `end`.
-   `params` (объект, опциональное): Параметры, специфичные для данного типа шага.

**Пример шага:**

```json
{
  "id": "greet_user",
  "type": "message",
  "description": "Отправляет приветственное сообщение",
  "params": {
    "text": "Привет, {user_name}!"
  },
  "next_step_id": "ask_question"
}
```

## 3. Контекст (`context`)

Контекст (`context`) — это JSON-объект, который хранит данные на протяжении выполнения одного экземпляра сценария. Он передается от шага к шагу и может быть модифицирован.

-   **Инициализация**: Контекст инициализируется значениями из поля `initial_context` сценария.
-   **Доступ к данным**: Шаги могут читать значения из контекста. Например, для подстановки в текст сообщения: `"text": "Привет, {user_name}!"` будет использовать значение `user_name` из контекста.
-   **Запись данных**: Некоторые типы шагов (например, `input`, `llm_request`, `rag_search`) могут записывать результаты своей работы в контекст. Обычно для этого используется параметр `output_var` в `params` шага, который указывает имя переменной в контексте, куда будет сохранен результат.

**Пример использования `output_var`:**

```json
{
  "id": "get_user_mood",
  "type": "input",
  "params": {
    "prompt": "Как ваше настроение?",
    "output_var": "user_mood_response" // Ответ пользователя будет сохранен в context.user_mood_response
  },
  "next_step_id": "react_to_mood"
}
```

## 4. Стандартные типы шагов

Эти типы шагов обрабатываются ядром системы (`ScenarioExecutor`) и доступны во всех сценариях.

### 4.1. `start`

-   **Назначение**: Формальное начало сценария. Обычно это первый шаг.
-   **Параметры (`params`)**: Не требует специфичных параметров.
-   **Поведение**: Может использоваться для инициализации каких-либо начальных значений в контексте, если это не сделано в `initial_context`.
-   **Пример**:
    ```json
    {
      "id": "start_scenario",
      "type": "start",
      "next_step_id": "step_after_start"
    }
    ```

### 4.2. `end`

-   **Назначение**: Формальное завершение сценария. После этого шага выполнение сценария прекращается.
-   **Параметры (`params`)**: Не требует специфичных параметров.
-   **Пример**:
    ```json
    {
      "id": "final_step",
      "type": "end"
    }
    ```

### 4.3. `message`

-   **Назначение**: Отправка простого текстового сообщения. Фактическая отправка (например, в Telegram или отображение в веб-интерфейсе) выполняется клиентской частью или соответствующим плагином интерфейса, который получает эту команду от исполнителя сценариев.
-   **Параметры (`params`)**:
    -   `text` (строка, обязательное): Текст сообщения. Может содержать плейсхолдеры для подстановки значений из контекста (например, `{user_name}`).
-   **Пример**:
    ```json
    {
      "id": "send_welcome_message",
      "type": "message",
      "params": {
        "text": "Добро пожаловать в систему!"
      },
      "next_step_id": "next_interaction"
    }
    ```

### 4.4. `input`

-   **Назначение**: Запрос ввода данных от пользователя. Как и `message`, фактическое отображение поля ввода и получение данных выполняется клиентской частью.
-   **Параметры (`params`)**:
    -   `prompt` (строка, обязательное): Текст-приглашение для ввода (например, "Введите ваше имя:").
    -   `output_var` (строка, обязательное): Имя переменной в контексте, куда будет сохранен ввод пользователя.
-   **Пример**:
    ```json
    {
      "id": "request_user_name",
      "type": "input",
      "params": {
        "prompt": "Пожалуйста, представьтесь:",
        "output_var": "user_provided_name"
      },
      "next_step_id": "greet_by_name"
    }
    ```

### 4.5. `branch`

-   **Назначение**: Ветвление логики сценария на основе условий. Условия проверяются последовательно. Выполняется переход к первому условию, которое истинно. Если ни одно условие не истинно, выполняется переход к `default_next_step_id`.
-   **Параметры (`params`)**:
    -   `conditions` (массив объектов, обязательное): Список условий для проверки. Каждое условие:
        -   `condition` (строка, обязательное): Выражение на Python, которое будет вычислено (`eval`) в контексте сценария. Должно возвращать `True` или `False`. Например, `"context.user_age >= 18"`.
        -   `next_step_id` (строка, обязательное): `id` шага, на который нужно перейти, если условие истинно.
    -   `default_next_step_id` (строка, обязательное): `id` шага, на который нужно перейти, если ни одно из условий не истинно.
-   **Пример**:
    ```json
    {
      "id": "check_user_consent",
      "type": "branch",
      "params": {
        "conditions": [
          {
            "condition": "context.consent_given == True",
            "next_step_id": "proceed_with_data"
          },
          {
            "condition": "context.consent_given == False",
            "next_step_id": "explain_consent_importance"
          }
        ],
        "default_next_step_id": "ask_for_consent_again"
      }
    }
    ```
    **Внимание**: Использование `eval` для условий требует осторожности. Убедитесь, что значения в контексте, используемые в условиях, безопасны.

### 4.6. `rag_search`

-   **Назначение**: Выполнение поиска по базе знаний с использованием RAG (Retrieval Augmented Generation) плагина.
-   **Параметры (`params`)**:
    -   `query` (строка, обязательное): Поисковый запрос. Может содержать плейсхолдеры для подстановки значений из контекста.
    -   `collection_name` (строка, опциональное, по умолчанию "default"): Имя коллекции в RAG, по которой будет производиться поиск.
    -   `output_var` (строка, обязательное): Имя переменной в контексте, куда будет сохранен результат поиска (обычно список документов или фрагментов текста).
-   **Пример**:
    ```json
    {
      "id": "find_info_about_product",
      "type": "rag_search",
      "params": {
        "query": "Расскажи мне о продукте {product_name}",
        "collection_name": "product_descriptions",
        "output_var": "rag_product_info"
      },
      "next_step_id": "display_product_info"
    }
    ```

### 4.7. `action`

-   **Назначение**: Выполнение предопределенного действия. Этот тип шага предназначен для вызова специфических функций, часто связанных с плагинами или внутренними операциями.
-   **Параметры (`params`)**:
    -   `action_type` (строка, обязательное): Тип выполняемого действия.
    -   Дополнительные параметры, зависящие от `action_type`.
-   **Примеры использования**:
    -   `action_type: "update_context"`: Позволяет модифицировать контекст сценария.
        -   `updates` (объект, обязательное): Словарь, где ключи - это имена переменных в контексте (можно использовать точку для вложенности, например, `user.profile.name`), а значения - новые значения для этих переменных. Значения могут быть литералами или строками с плейсхолдерами из контекста.
        ```json
        {
          "id": "update_user_info",
          "type": "action",
          "params": {
            "action_type": "update_context",
            "updates": {
              "user_name": "Новое Имя",
              "user_status": "{current_status}_updated",
              "profile.age": 30
            }
          },
          "next_step_id": "next_step_after_update"
        }
        ```
    -   Другие `action_type` могут быть предоставлены плагинами. Например, `TelegramPlugin` обрабатывает `action_type: "telegram_send_message"`. См. детали в разделе **5.1. `telegram_send_message`**.

### 4.8. `execute_sub_scenario`

-   **Назначение**: Запуск другого (вложенного) сценария. Позволяет декомпозировать сложную логику на более мелкие, переиспользуемые сценарии.
-   **Параметры (`params`)**:
    -   `sub_scenario_id` (строка, обязательное): `id` сценария, который нужно запустить.
    -   `input_mapping` (объект, опциональное): Определяет, какие значения из контекста родительского сценария будут переданы в начальный контекст под-сценария.
        -   Ключ: имя переменной в контексте под-сценария.
        -   Значение: имя переменной в контексте родительского сценария ИЛИ литеральное значение.
    -   `output_mapping` (объект, опциональное): Определяет, какие значения из финального контекста под-сценария будут скопированы обратно в контекст родительского сценария.
        -   Ключ: имя переменной в контексте родительского сценария.
        -   Значение: имя переменной в контексте под-сценария ИЛИ литеральное значение.
-   **Пример**:
    ```json
    {
      "id": "run_user_onboarding_sub_scenario",
      "type": "execute_sub_scenario",
      "params": {
        "sub_scenario_id": "user_onboarding_flow",
        "input_mapping": {
          "initial_user_id": "global_user_id", // context.initial_user_id (sub) = context.global_user_id (parent)
          "onboarding_type": "full" // context.onboarding_type (sub) = "full" (literal)
        },
        "output_mapping": {
          "onboarding_result_status": "final_status", // context.onboarding_result_status (parent) = context.final_status (sub)
          "user_profile_updated": "profile_completed_flag" 
        }
      },
      "next_step_id": "post_onboarding_step"
    }
    ```

### 4.9. Шаги для работы с MongoDB (предоставляются `MongoStoragePlugin`)

Плагин `MongoStoragePlugin` позволяет сценариям напрямую взаимодействовать с коллекциями MongoDB для сохранения, чтения, обновления и удаления данных.

#### 4.9.1. `mongo_insert_one`

-   **Назначение**: Вставка одного документа в указанную коллекцию.
-   **Параметры (`params`)**:
    -   `collection_name` (строка, обязательное): Имя коллекции MongoDB.
    -   `document` (объект, обязательное): Документ для вставки. Значения могут быть литералами или строками-плейсхолдерами вида `{context_var_name}` для подстановки из текущего контекста сценария (только для верхнего уровня ключей).
    -   `output_var` (строка, опционально, по умолчанию `mongo_inserted_id`): Имя переменной в контексте, куда будет сохранен строковый `_id` вставленного документа.
-   **Пример**:
    ```json
    {
      "id": "save_user_feedback",
      "type": "mongo_insert_one",
      "params": {
        "collection_name": "feedbacks",
        "document": {
          "user_id": "{user.id}",
          "text": "{user_input_text}",
          "rating": 5,
          "created_at": "{current_timestamp}"
        },
        "output_var": "feedback_id"
      },
      "next_step_id": "thank_user_for_feedback"
    }
    ```

#### 4.9.2. `mongo_find_one`

-   **Назначение**: Поиск одного документа в указанной коллекции по фильтру.
-   **Параметры (`params`)**:
    -   `collection_name` (строка, обязательное): Имя коллекции MongoDB.
    -   `filter` (объект, обязательное): Фильтр для поиска в формате MongoDB (например, `{"user_id": "123"}`). Подстановка из контекста в фильтр пока не реализована.
    -   `output_var` (строка, опционально, по умолчанию `mongo_found_document`): Имя переменной в контексте, куда будет сохранен найденный документ (или `null`, если не найден). `_id` будет автоматически преобразован в строку.
-   **Пример**:
    ```json
    {
      "id": "get_user_preferences",
      "type": "mongo_find_one",
      "params": {
        "collection_name": "user_preferences",
        "filter": {"user_id": "{telegram_chat_id}"},
        "output_var": "user_prefs"
      },
      "next_step_id": "process_preferences"
    }
    ```

#### 4.9.3. `mongo_update_one`

-   **Назначение**: Обновление одного документа, соответствующего фильтру.
-   **Параметры (`params`)**:
    -   `collection_name` (строка, обязательное): Имя коллекции MongoDB.
    -   `filter` (объект, обязательное): Фильтр для поиска документа для обновления.
    -   `update_document` (объект, обязательное): Документ с операциями обновления (например, `{"$set": {"status": "completed"}}`).
    -   `upsert` (булево, опционально, по умолчанию `false`): Если `true`, будет создан новый документ, если ни один не соответствует фильтру.
    -   `output_var_modified_count` (строка, опционально, по умолчанию `mongo_modified_count`): Имя переменной для количества измененных документов.
    -   `output_var_upserted_id` (строка, опционально, по умолчанию `mongo_upserted_id`): Имя переменной для `_id` вставленного документа (если `upsert` был `true` и произошла вставка).
-   **Пример**:
    ```json
    {
      "id": "mark_order_completed",
      "type": "mongo_update_one",
      "params": {
        "collection_name": "orders",
        "filter": {"_id": "{order_id_from_context}"},
        "update_document": {"$set": {"status": "completed", "completed_at": "{now}"}},
        "upsert": false
      },
      "next_step_id": "notify_completion"
    }
    ```

#### 4.9.4. `mongo_delete_one`

-   **Назначение**: Удаление одного документа, соответствующего фильтру.
-   **Параметры (`params`)**:
    -   `collection_name` (строка, обязательное): Имя коллекции MongoDB.
    -   `filter` (объект, обязательное): Фильтр для поиска документа для удаления.
    -   `output_var_deleted_count` (строка, опционально, по умолчанию `mongo_deleted_count`): Имя переменной для количества удаленных документов (0 или 1).
-   **Пример**:
    ```json
    {
      "id": "cancel_pending_order",
      "type": "mongo_delete_one",
      "params": {
        "collection_name": "orders",
        "filter": {"_id": "{order_to_cancel_id}", "status": "pending"}
      },
      "next_step_id": "confirm_cancellation"
    }
    ```

### 4.10. Шаги для планирования задач (предоставляются `SchedulingPlugin`)

Плагин `SchedulingPlugin` позволяет планировать запуск других сценариев через определенное время. Для корректной работы шага планирования в контексте сценария должна присутствовать переменная `initiator_user_id`, содержащая идентификатор пользователя, инициировавшего операцию.

#### 4.10.1. `schedule_scenario_run`

-   **Назначение**: Запланировать запуск другого сценария, выполняемого определенным агентом, через указанное количество секунд.
-   **Параметры (`params`)**:
    -   `run_in_seconds` (число, обязательное): Через сколько секунд от текущего момента запустить сценарий.
    -   `agent_id_to_run_scenario` (строка, обязательное): ID агента, ассоциированный сценарий которого должен быть запущен.
    -   `context_to_pass` (объект, опционально, по умолчанию `{}`): Словарь, который будет передан как начальный контекст (`initial_context`) запускаемому сценарию. Значения могут быть литералами или строками-плейсхолдерами `{context_var_name}`.
    -   `task_id_output_var` (строка, опционально): Если указано, ID созданной задачи в планировщике будет сохранен в контексте текущего сценария под этим именем.
-   **Пример**:
    ```json
    {
      "id": "schedule_follow_up",
      "type": "schedule_scenario_run",
      "params": {
        "run_in_seconds": 86400, // 1 день
        "agent_id_to_run_scenario": "id_агента_для_фоллоу_ап_сценария",
        "context_to_pass": {
          "original_user_id": "{user_id}",
          "original_chat_id": "{chat_id}",
          "case_id": "{current_case_id}"
        },
        "task_id_output_var": "follow_up_task_id"
      },
      "next_step_id": "confirmation_scheduled"
    }
    ```

## 5. Шаги, специфичные для плагинов

Некоторые типы шагов тесно связаны с функциональностью конкретных плагинов.

### 5.1. `telegram_send_message`

Этот шаг специфичен для взаимодействия с Telegram и обрабатывается `TelegramPlugin`. Его можно вызывать либо напрямую с `type: "telegram_send_message"`, либо через шаг `action` с `action_type: "telegram_send_message"`.

-   **Назначение**: Отправка сообщения в Telegram, возможно с клавиатурами.
-   **Параметры (`params`)**:
    -   `chat_id` (строка или число, обязательное): ID чата Telegram. Обычно берется из контекста (`{telegram_chat_id}`).
    -   `text` (строка, обязательное): Текст сообщения. Может содержать плейсхолдеры.
    -   `parse_mode` (строка, опциональное): Режим парсинга для форматирования текста (например, `MarkdownV2`, `HTML`).
    -   `inline_keyboard` (массив массивов объектов, опциональное): Для создания inline-клавиатуры (кнопки под сообщением).
        -   Каждый объект кнопки: `{"text": "Текст кнопки", "callback_data": "данные_для_обработки"}`.
        -   Пример: `[[{"text": "Опция 1", "callback_data": "opt1"}], [{"text": "Опция 2", "callback_data": "opt2"}]]`
    -   `reply_keyboard` (массив массивов объектов, опциональное): Для создания reply-клавиатуры (кнопки вместо стандартной клавиатуры).
        -   Каждый объект кнопки: `{"text": "Текст кнопки"}`. Reply-кнопки просто отправляют свой текст как сообщение.
        -   Пример: `[[{"text": "Да"}, {"text": "Нет"}], [{"text": "{Специальная команда}"}]]`
    -   `one_time_keyboard` (булево, опциональное, по умолчанию `false`): Если `true`, reply-клавиатура будет скрыта после нажатия на кнопку.
    -   `remove_keyboard` (булево, опциональное, по умолчанию `false`): Если `true`, текущая reply-клавиатура будет удалена. `text` все равно обязателен и будет отправлен.
    -   `resize_keyboard` (булево, опциональное, по умолчанию `true`): Если `true`, размер reply-клавиатуры будет автоматически подстроен.
    -   `input_field_placeholder` (строка, опциональное): Плейсхолдер для поля ввода текста, когда активна reply-клавиатура.
    -   `selective` (булево, опциональное, по умолчанию `false`): Используется с `remove_keyboard` и `reply_keyboard`. Если `true`, клавиатура будет показана/скрыта только для определенных пользователей (тех, кто упоминается в сообщении, или отправителя, если сообщение является ответом).
    -   `message_id_to_edit` (число, опциональное): ID сообщения, которое нужно отредактировать.
        -   **Важно**: Редактирование reply-клавиатуры существующего сообщения невозможно. Можно редактировать текст и inline-клавиатуру.

-   **Пример с Inline Keyboard**:
    ```json
    {
      "id": "send_with_inline_buttons",
      "type": "telegram_send_message", 
      "params": {
        "chat_id": "{telegram_chat_id}",
        "text": "Выберите опцию:",
        "inline_keyboard": [
          [{"text": "Опция A", "callback_data": "option_a"}],
          [{"text": "Опция B", "callback_data": "option_b"}]
        ]
      },
      "next_step_id": "wait_for_inline_choice"
    }
    ```
-   **Пример с Reply Keyboard**:
    ```json
    {
      "id": "ask_with_reply_buttons",
      "type": "telegram_send_message",
      "params": {
        "chat_id": "{telegram_chat_id}",
        "text": "Выберите действие:",
        "reply_keyboard": [
          [{"text": "Узнать больше"}, {"text": "Пропустить"}],
          [{"text": "{Помощь}"}]
        ],
        "one_time_keyboard": true
      },
      "next_step_id": "wait_for_reply_choice"
    }
    ```
-   **Пример с удалением Reply Keyboard**:
    ```json
    {
      "id": "remove_reply_markup_step",
      "type": "telegram_send_message",
      "params": {
        "chat_id": "{telegram_chat_id}",
        "text": "Клавиатура удалена.",
        "remove_keyboard": true
      },
      "next_step_id": "proceed_without_keyboard"
    }
    ```

### 5.2. `llm_query` (Плагин LLM)

-   **Назначение**: Отправка запроса к языковой модели (LLM) и получение ответа.
-   **Параметры (`params`)**:
    -   `model` (строка, опциональное): Имя или идентификатор модели LLM для использования (например, "gpt-3.5-turbo", "claude-2"). Если не указано, используется модель по умолчанию из конфигурации плагина.
    -   `messages` (массив объектов, обязательное, если не используются `system_prompt_var` и `user_prompt_var`): История диалога в формате OpenAI.
        -   Каждый объект: `{"role": "system" | "user" | "assistant", "content": "текст сообщения"}`.
    -   `system_prompt_var` (строка, опциональное): Имя переменной в контексте, содержащей системный промпт. Если указано, используется вместо или в дополнение к системному сообщению в `messages`.
    -   `user_prompt_var` (строка, опциональное): Имя переменной в контексте, содержащей последний запрос пользователя. Используется для формирования финального запроса.
    -   `temperature` (число, опциональное): Температура для генерации ответа (контролирует случайность).
    -   `output_var` (строка, обязательное): Имя переменной в контексте, куда будет сохранен ответ LLM (обычно текстовая строка).
-   **Пример**:
    ```json
    {
      "id": "get_llm_summary",
      "type": "llm_query",
      "params": {
        "messages": [
          {"role": "system", "content": "Ты — полезный ассистент, который суммирует текст."},
          {"role": "user", "content": "Пожалуйста, суммируй следующий текст: {text_to_summarize}"} // text_to_summarize из контекста
        ],
        "output_var": "llm_summary_result"
      },
      "next_step_id": "display_summary"
    }
    ```

## 6. Обработка ошибок

-   Если при выполнении шага возникает ошибка, исполнитель сценариев может записать информацию об ошибке в контекст.
    -   `context.__step_error__`: Содержит сообщение об ошибке последнего неудачно выполненного шага.
-   Если происходит более общая ошибка при выполнении всего сценария (например, не найден под-сценарий), может быть установлена переменная `context.__scenario_error__`.
-   Сценарии могут использовать шаг `branch` для проверки наличия этих переменных и соответствующей реакции на ошибки.

## 7. Шаблонизация параметров

Многие текстовые параметры шагов (например, `text` в `message`, `query` в `rag_search`, `content` в `llm_request`) поддерживают шаблонизацию с использованием фигурных скобок `{}` для подстановки значений из текущего контекста сценария.

Например, если в контексте есть `{"user_name": "Алиса", "item_count": 5}`, то параметр:
`"text": "Привет, {user_name}! У вас {item_count} новых сообщений."`
будет преобразован в:
`"text": "Привет, Алиса! У вас 5 новых сообщений."`

## 8. Важные аспекты и отсутствующие возможности (для сложных сценариев)

При разработке сложных сценариев, таких как ваш многоэтапный тест с пиццей, важно учитывать текущие ограничения системы:

### 8.1. Произвольные операции с базой данных

-   **Текущее состояние**: В настоящее время **нет стандартных типов шагов** для выполнения произвольных операций с базой данных, таких как:
    -   Запись произвольных данных пользователя (например, ответы на вопросы теста, пометка о прохождении).
    -   Чтение этих данных для последующей логики (например, проверка, проходил ли пользователь тест ранее).
-   **Влияние**: Это является **ключевым ограничением** для реализации вашего тестового сценария, где требуется сохранять ответы и состояние пользователя ("В базу пользователей сохраняются ответы и пометка о том, что я прошёл тест", "и если я жму на старт - то опрос не запускается повторно!").
-   **Возможные пути решения (требуют доработки системы или плагинов)**:
    1.  Создание нового плагина, предоставляющего шаги типа `db_write_item`, `db_read_item`, `db_update_item`.
    2.  Расширение существующего плагина (например, `TelegramPlugin` или нового "UserPlugin") для взаимодействия с базой данных пользователей.

### 8.2. Вызов произвольных API

-   **Текущее состояние**: **Нет стандартного типа шага** `api_call` для выполнения произвольных HTTP-запросов к внешним сервисам из сценария.
-   **Влияние**: Если для логики сценария требуется интеграция с внешним API (не LLM, не RAG, не Telegram), это будет затруднительно.
-   **Возможные пути решения**:
    1.  Создание плагина, который предоставляет шаг `api_call`.

### 8.3. Планирование задач

-   **Текущее состояние**: Функциональность планирования задач доступна через `SchedulingPlugin`, который предоставляет шаг `schedule_scenario_run`. Этот плагин позволяет откладывать запуск сценариев, связанных с определенными агентами. `SchedulerService` существует в системе и используется этим плагином.
-   **Влияние**: Реализация отложенных задач и напоминаний возможна с использованием `SchedulingPlugin`.
-   **Возможные пути решения**: Не требуются для базового планирования запуска сценариев; существующий плагин покрывает эту функциональность.

**Вывод**: Для полной реализации вашего тестового сценария **только средствами существующих типов шагов сценариев** потребуется предварительная доработка системы или создание/модификация плагинов для обеспечения функциональности работы с БД. Части сценария, связанные с опросом, вызовом LLM, взаимодействием через Telegram и базовым планированием задач, могут быть реализованы с текущими возможностями. 