"""
üóÑÔ∏è ObsidianDB - –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –æ—Å–Ω–æ–≤–µ Obsidian

–ï–¥–∏–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö –∞–≥–µ–Ω—Ç–æ–≤ KittyCore 3.0:
- –í—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–≥–µ–Ω—Ç–æ–≤ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –∫–∞–∫ .md —Ñ–∞–π–ª—ã
- –ê–≥–µ–Ω—Ç—ã —á–∏—Ç–∞—é—Ç –∏ –ø–∏—à—É—Ç —á–µ—Ä–µ–∑ ObsidianDB
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Å–≤—è–∑–∏ –º–µ–∂–¥—É –∑–∞–º–µ—Ç–∫–∞–º–∏
- –í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –∏—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
- –ü–æ–∏—Å–∫ –∏ –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞

–°—Ç—Ä—É–∫—Ç—É—Ä–∞:
üìÅ obsidian_vault/
‚îú‚îÄ‚îÄ üìÅ tasks/           ‚Üê –ó–∞–¥–∞—á–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
‚îú‚îÄ‚îÄ üìÅ agents/          ‚Üê –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞–±–æ—Ç—ã –∞–≥–µ–Ω—Ç–æ–≤  
‚îú‚îÄ‚îÄ üìÅ coordination/    ‚Üê –ö–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è –º–µ–∂–¥—É –∞–≥–µ–Ω—Ç–∞–º–∏
‚îú‚îÄ‚îÄ üìÅ results/         ‚Üê –§–∏–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
‚îî‚îÄ‚îÄ üìÅ system/          ‚Üê –°–∏—Å—Ç–µ–º–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
"""

import os
import json
import yaml
from datetime import datetime
from typing import Dict, Any, List, Optional, Union
from pathlib import Path
import hashlib
import re

from loguru import logger

class ObsidianNote:
    """–ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏ Obsidian"""
    
    def __init__(self, title: str, content: str = "", tags: List[str] = None, 
                 metadata: Dict[str, Any] = None, folder: str = ""):
        self.title = title
        self.content = content
        self.tags = tags or []
        self.metadata = metadata or {}
        self.folder = folder
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
        
    def to_markdown(self) -> str:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –≤ Obsidian-—Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π markdown"""
        lines = []
        
        # YAML frontmatter —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
        if self.metadata or self.tags:
            lines.append("---")
            
            # –ë–∞–∑–æ–≤—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            lines.append(f"created: {self.created_at.isoformat()}")
            lines.append(f"updated: {self.updated_at.isoformat()}")
            
            # –¢–µ–≥–∏
            if self.tags:
                lines.append(f"tags: [{', '.join(self.tags)}]")
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            for key, value in self.metadata.items():
                if isinstance(value, (str, int, float, bool)):
                    lines.append(f"{key}: {value}")
                elif isinstance(value, datetime):
                    lines.append(f"{key}: {value.isoformat()}")
                else:
                    try:
                        lines.append(f"{key}: {json.dumps(value)}")
                    except TypeError:
                        lines.append(f"{key}: {str(value)}")
                    
            lines.append("---")
            lines.append("")
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        lines.append(f"# {self.title}")
        lines.append("")
        
        # –ö–æ–Ω—Ç–µ–Ω—Ç
        lines.append(self.content)
        
        return "\n".join(lines)
    
    @classmethod
    def from_markdown(cls, filepath: str) -> 'ObsidianNote':
        """–°–æ–∑–¥–∞—ë—Ç –∑–∞–º–µ—Ç–∫—É –∏–∑ markdown —Ñ–∞–π–ª–∞"""
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # –ü–∞—Ä—Å–∏–º YAML frontmatter
        metadata = {}
        tags = []
        
        if content.startswith("---"):
            parts = content.split("---", 2)
            if len(parts) >= 3:
                yaml_content = parts[1].strip()
                main_content = parts[2].strip()
                
                try:
                    yaml_data = yaml.safe_load(yaml_content)
                    if yaml_data:
                        tags = yaml_data.pop("tags", [])
                        metadata = yaml_data
                except:
                    main_content = content
            else:
                main_content = content
        else:
            main_content = content
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
        title_match = re.search(r'^# (.+)$', main_content, re.MULTILINE)
        title = title_match.group(1) if title_match else Path(filepath).stem
        
        # –£–±–∏—Ä–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏–∑ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
        if title_match:
            main_content = main_content.replace(title_match.group(0), "").strip()
        
        note = cls(title=title, content=main_content, tags=tags, metadata=metadata)
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞—Ç—ã –∏–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
        if "created" in metadata:
            try:
                note.created_at = datetime.fromisoformat(metadata["created"])
            except:
                pass
                
        if "updated" in metadata:
            try:
                note.updated_at = datetime.fromisoformat(metadata["updated"])
            except:
                pass
        
        return note

class ObsidianDB:
    """–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –æ—Å–Ω–æ–≤–µ Obsidian"""
    
    def __init__(self, vault_path: str = "./obsidian_vault"):
        self.vault_path = Path(vault_path)
        self.vault_path.mkdir(exist_ok=True)
        
        # –°–æ–∑–¥–∞—ë–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–∞–ø–æ–∫
        self.folders = {
            "tasks": self.vault_path / "tasks",
            "agents": self.vault_path / "agents", 
            "coordination": self.vault_path / "coordination",
            "results": self.vault_path / "results",
            "system": self.vault_path / "system"
        }
        
        for folder in self.folders.values():
            folder.mkdir(exist_ok=True)
            
        # –ò–Ω–¥–µ–∫—Å –∑–∞–º–µ—Ç–æ–∫ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
        self._notes_index = {}
        self._rebuild_index()
        
        logger.info(f"üóÑÔ∏è ObsidianDB –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞: {vault_path}")
    
    def _rebuild_index(self):
        """–ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –∏–Ω–¥–µ–∫—Å –≤—Å–µ—Ö –∑–∞–º–µ—Ç–æ–∫"""
        self._notes_index = {}
        
        for md_file in self.vault_path.rglob("*.md"):
            try:
                note = ObsidianNote.from_markdown(str(md_file))
                relative_path = md_file.relative_to(self.vault_path)
                self._notes_index[str(relative_path)] = {
                    "title": note.title,
                    "tags": note.tags,
                    "metadata": note.metadata,
                    "created": note.created_at,
                    "updated": note.updated_at,
                    "path": str(md_file)
                }
            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞—Ç—å {md_file}: {e}")
    
    def save_note(self, note: ObsidianNote, filename: str = None) -> str:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∑–∞–º–µ—Ç–∫—É –≤ vault"""
        if not filename:
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞
            safe_title = re.sub(r'[^\w\s-]', '', note.title)
            safe_title = re.sub(r'[-\s]+', '-', safe_title)
            filename = f"{safe_title}.md"
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–∞–ø–∫—É –∏–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        folder_name = note.metadata.get("folder", note.folder or "system")
        folder_path = self.folders.get(folder_name, self.folders["system"])
        
        filepath = folder_path / filename
        note.updated_at = datetime.now()
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(note.to_markdown())
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å
        relative_path = filepath.relative_to(self.vault_path)
        self._notes_index[str(relative_path)] = {
            "title": note.title,
            "tags": note.tags,
            "metadata": note.metadata,
            "created": note.created_at,
            "updated": note.updated_at,
            "path": str(filepath)
        }
        
        logger.debug(f"üíæ –ó–∞–º–µ—Ç–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {relative_path}")
        return str(filepath)
    
    def get_note(self, filename: str) -> Optional[ObsidianNote]:
        """–ü–æ–ª—É—á–∞–µ—Ç –∑–∞–º–µ—Ç–∫—É –ø–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
        # –ò—â–µ–º —Ñ–∞–π–ª –≤ –∏–Ω–¥–µ–∫—Å–µ
        for path, info in self._notes_index.items():
            if Path(path).name == filename or Path(path).stem == filename:
                return ObsidianNote.from_markdown(info["path"])
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –∏–Ω–¥–µ–∫—Å–µ, –∏—â–µ–º –Ω–∞–ø—Ä—è–º—É—é
        for folder in self.folders.values():
            filepath = folder / filename
            if not filepath.suffix:
                filepath = filepath.with_suffix('.md')
            
            if filepath.exists():
                return ObsidianNote.from_markdown(str(filepath))
        
        return None
    
    def search_notes(self, query: str = "", tags: List[str] = None, 
                    folder: str = None, metadata_filter: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """–ü–æ–∏—Å–∫ –∑–∞–º–µ—Ç–æ–∫ –ø–æ —Ä–∞–∑–ª–∏—á–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º"""
        results = []
        
        for path, info in self._notes_index.items():
            match = True
            
            # –§–∏–ª—å—Ç—Ä –ø–æ —Ç–µ–∫—Å—Ç—É
            if query:
                if query.lower() not in info["title"].lower():
                    try:
                        note = ObsidianNote.from_markdown(info["path"])
                        if query.lower() not in note.content.lower():
                            match = False
                    except:
                        match = False
            
            # –§–∏–ª—å—Ç—Ä –ø–æ —Ç–µ–≥–∞–º
            if tags and match:
                if not any(tag in info["tags"] for tag in tags):
                    match = False
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –ø–∞–ø–∫–µ
            if folder and match:
                if not str(path).startswith(folder):
                    match = False
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º
            if metadata_filter and match:
                for key, value in metadata_filter.items():
                    if info["metadata"].get(key) != value:
                        match = False
                        break
            
            if match:
                results.append({
                    "path": path,
                    "title": info["title"],
                    "tags": info["tags"],
                    "metadata": info["metadata"],
                    "created": info["created"],
                    "updated": info["updated"]
                })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (–Ω–æ–≤—ã–µ –ø–µ—Ä–≤—ã–º–∏)
        results.sort(key=lambda x: x["updated"], reverse=True)
        return results
    
    def create_link(self, from_note: str, to_note: str, link_text: str = None) -> bool:
        """–°–æ–∑–¥–∞—ë—Ç —Å–≤—è–∑—å –º–µ–∂–¥—É –∑–∞–º–µ—Ç–∫–∞–º–∏ (Obsidian-style)"""
        note = self.get_note(from_note)
        if not note:
            return False
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ Obsidian
        to_title = Path(to_note).stem
        if link_text:
            link = f"[[{to_title}|{link_text}]]"
        else:
            link = f"[[{to_title}]]"
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –≤ –∫–æ–Ω–µ—Ü –∑–∞–º–µ—Ç–∫–∏
        if link not in note.content:
            note.content += f"\n\n{link}"
            self.save_note(note, from_note)
        
        return True
    
    def get_backlinks(self, note_title: str) -> List[str]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –∑–∞–º–µ—Ç–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ —Å—Å—ã–ª–∞—é—Ç—Å—è –Ω–∞ –¥–∞–Ω–Ω—É—é"""
        backlinks = []
        link_pattern = rf"\[\[{re.escape(note_title)}(?:\|[^\]]+)?\]\]"
        
        for path, info in self._notes_index.items():
            try:
                note = ObsidianNote.from_markdown(info["path"])
                if re.search(link_pattern, note.content):
                    backlinks.append(info["title"])
            except:
                continue
        
        return backlinks
    
    async def save_artifact(self, agent_id: str, content: str, artifact_type: str = "file", filename: str = None) -> str:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∞—Ä—Ç–µ—Ñ–∞–∫—Ç –∞–≥–µ–Ω—Ç–∞ –≤ ObsidianDB"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        if not filename:
            filename = f"{artifact_type}_{timestamp}.md"
        else:
            # –£–±–∏—Ä–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å –∏ –¥–æ–±–∞–≤–ª—è–µ–º .md
            base_name = Path(filename).stem
            filename = f"{base_name}_{timestamp}.md"
        
        note = ObsidianNote(
            title=f"{agent_id} - {artifact_type} - {filename}",
            content=content,
            tags=[agent_id, artifact_type, "artifact"],
            metadata={
                "agent_id": agent_id,
                "artifact_type": artifact_type,
                "original_filename": filename,
                "created_timestamp": timestamp,
                "folder": f"agents/{agent_id}/artifacts"
            },
            folder=f"agents/{agent_id}/artifacts"
        )
        
        # –°–æ–∑–¥–∞—ë–º –ø–∞–ø–∫—É –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        artifact_folder = self.vault_path / "agents" / agent_id / "artifacts"
        artifact_folder.mkdir(parents=True, exist_ok=True)
        
        artifact_filename = f"{agent_id}_artifact_{timestamp}.md"
        filepath = self.save_note(note, artifact_filename)
        
        logger.debug(f"üíé –ê—Ä—Ç–µ—Ñ–∞–∫—Ç {artifact_type} —Å–æ—Ö—Ä–∞–Ω—ë–Ω –¥–ª—è {agent_id}: {filepath}")
        return filepath

class AgentWorkspace:
    """–†–∞–±–æ—á–µ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∞–≥–µ–Ω—Ç–∞ –≤ ObsidianDB"""
    
    def __init__(self, agent_id: str, obsidian_db: ObsidianDB):
        self.agent_id = agent_id
        self.db = obsidian_db
        self.workspace_folder = f"agents/{agent_id}"
        
        # –°–æ–∑–¥–∞—ë–º –ø–∞–ø–∫—É –∞–≥–µ–Ω—Ç–∞
        agent_folder = self.db.vault_path / "agents" / agent_id
        agent_folder.mkdir(exist_ok=True)
        
        logger.debug(f"ü§ñ –†–∞–±–æ—á–µ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∞–≥–µ–Ω—Ç–∞ {agent_id} –≥–æ—Ç–æ–≤–æ")
    
    def save_result(self, task_id: str, content: str, result_type: str = "result") -> str:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–±–æ—Ç—ã –∞–≥–µ–Ω—Ç–∞"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        note = ObsidianNote(
            title=f"{self.agent_id} - {result_type} - {task_id}",
            content=content,
            tags=[self.agent_id, result_type, "agent-output"],
            metadata={
                "agent_id": self.agent_id,
                "task_id": task_id,
                "result_type": result_type,
                "timestamp": timestamp,
                "folder": "agents"
            },
            folder="agents"
        )
        
        filename = f"{self.agent_id}_{result_type}_{timestamp}.md"
        filepath = self.db.save_note(note, filename)
        
        logger.info(f"üíæ –ê–≥–µ–Ω—Ç {self.agent_id} —Å–æ—Ö—Ä–∞–Ω–∏–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {filename}")
        return filepath
    
    def get_task_context(self, task_id: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∞–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –∑–∞–¥–∞—á–∏ –∏–∑ –¥—Ä—É–≥–∏—Ö –∞–≥–µ–Ω—Ç–æ–≤"""
        # –ò—â–µ–º –≤—Å–µ –∑–∞–º–µ—Ç–∫–∏ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –∑–∞–¥–∞—á–µ–π
        related_notes = self.db.search_notes(
            metadata_filter={"task_id": task_id}
        )
        
        context = {
            "task_id": task_id,
            "related_agents": [],
            "previous_results": [],
            "coordination_notes": []
        }
        
        for note_info in related_notes:
            if note_info["metadata"].get("agent_id") != self.agent_id:
                context["related_agents"].append(note_info["metadata"].get("agent_id"))
                
                if note_info["metadata"].get("result_type") == "result":
                    note = self.db.get_note(note_info["path"])
                    if note:
                        context["previous_results"].append({
                            "agent": note_info["metadata"].get("agent_id"),
                            "content": note.content[:500] + "..." if len(note.content) > 500 else note.content,
                            "timestamp": note_info["updated"]
                        })
        
        return context
    
    def coordinate_with_agent(self, other_agent_id: str, message: str, task_id: str) -> str:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –¥—Ä—É–≥–æ–º—É –∞–≥–µ–Ω—Ç—É —á–µ—Ä–µ–∑ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–æ–Ω–Ω—É—é –∑–∞–º–µ—Ç–∫—É"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        note = ObsidianNote(
            title=f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è: {self.agent_id} ‚Üí {other_agent_id}",
            content=f"**–û—Ç:** {self.agent_id}\n**–ö:** {other_agent_id}\n**–ó–∞–¥–∞—á–∞:** {task_id}\n\n{message}",
            tags=["coordination", self.agent_id, other_agent_id],
            metadata={
                "from_agent": self.agent_id,
                "to_agent": other_agent_id,
                "task_id": task_id,
                "message_type": "coordination",
                "timestamp": timestamp,
                "folder": "coordination"
            },
            folder="coordination"
        )
        
        filename = f"coord_{self.agent_id}_to_{other_agent_id}_{timestamp}.md"
        filepath = self.db.save_note(note, filename)
        
        logger.info(f"üì® {self.agent_id} –æ—Ç–ø—Ä–∞–≤–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ {other_agent_id}")
        return filepath
    
    def get_messages_for_me(self, task_id: str = None) -> List[Dict[str, Any]]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∞–¥—Ä–µ—Å–æ–≤–∞–Ω–Ω—ã–µ —ç—Ç–æ–º—É –∞–≥–µ–Ω—Ç—É"""
        filter_criteria = {"to_agent": self.agent_id}
        if task_id:
            filter_criteria["task_id"] = task_id
        
        messages = self.db.search_notes(
            folder="coordination",
            metadata_filter=filter_criteria
        )
        
        result = []
        for msg_info in messages:
            note = self.db.get_note(msg_info["path"])
            if note:
                result.append({
                    "from_agent": msg_info["metadata"].get("from_agent"),
                    "content": note.content,
                    "timestamp": msg_info["updated"],
                    "task_id": msg_info["metadata"].get("task_id")
                })
        
        return result

class TaskManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –∑–∞–¥–∞—á –≤ ObsidianDB"""
    
    def __init__(self, obsidian_db: ObsidianDB):
        self.db = obsidian_db
        
    def create_task(self, task_description: str, user_id: str = None) -> str:
        """–°–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É"""
        task_id = hashlib.md5(f"{task_description}{datetime.now()}".encode()).hexdigest()[:8]
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        note = ObsidianNote(
            title=f"–ó–∞–¥–∞—á–∞: {task_description[:50]}...",
            content=f"""## –û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏

{task_description}

## –°—Ç–∞—Ç—É—Å
- **ID –∑–∞–¥–∞—á–∏:** {task_id}
- **–°–æ–∑–¥–∞–Ω–∞:** {datetime.now().isoformat()}
- **–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** {user_id or 'anonymous'}
- **–°—Ç–∞—Ç—É—Å:** –í —Ä–∞–±–æ—Ç–µ

## –ê–≥–µ–Ω—Ç—ã
*–ê–≥–µ–Ω—Ç—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏*

## –†–µ–∑—É–ª—å—Ç–∞—Ç—ã
*–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ –º–µ—Ä–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è*

## –°–≤—è–∑–∞–Ω–Ω—ã–µ –∑–∞–º–µ—Ç–∫–∏
""",
            tags=["task", "active", task_id],
            metadata={
                "task_id": task_id,
                "user_id": user_id,
                "status": "active",
                "created_timestamp": timestamp,
                "folder": "tasks"
            },
            folder="tasks"
        )
        
        filename = f"task_{task_id}_{timestamp}.md"
        filepath = self.db.save_note(note, filename)
        
        logger.info(f"üìã –°–æ–∑–¥–∞–Ω–∞ –∑–∞–¥–∞—á–∞ {task_id}: {task_description[:50]}...")
        return task_id
    
    def update_task_status(self, task_id: str, status: str, details: str = ""):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏"""
        # –ù–∞—Ö–æ–¥–∏–º –∑–∞–º–µ—Ç–∫—É –∑–∞–¥–∞—á–∏
        task_notes = self.db.search_notes(metadata_filter={"task_id": task_id})
        
        for note_info in task_notes:
            if note_info["metadata"].get("folder") == "tasks":
                note = self.db.get_note(note_info["path"])
                if note:
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
                    note.metadata["status"] = status
                    note.metadata["updated_timestamp"] = datetime.now().strftime("%Y%m%d_%H%M%S")
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–≥–∏
                    note.tags = [tag for tag in note.tags if tag not in ["active", "completed", "failed"]]
                    note.tags.append(status)
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª–∏ –≤ –∫–æ–Ω—Ç–µ–Ω—Ç
                    if details:
                        note.content += f"\n\n### –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ ({datetime.now().strftime('%H:%M:%S')})\n**–°—Ç–∞—Ç—É—Å:** {status}\n{details}"
                    
                    self.db.save_note(note, Path(note_info["path"]).name)
                    logger.info(f"üìã –ó–∞–¥–∞—á–∞ {task_id} –æ–±–Ω–æ–≤–ª–µ–Ω–∞: {status}")
                    break
    
    def add_agent_to_task(self, task_id: str, agent_id: str, role: str = ""):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –∞–≥–µ–Ω—Ç–∞ –∫ –∑–∞–¥–∞—á–µ"""
        task_notes = self.db.search_notes(metadata_filter={"task_id": task_id})
        
        for note_info in task_notes:
            if note_info["metadata"].get("folder") == "tasks":
                note = self.db.get_note(note_info["path"])
                if note:
                    # –î–æ–±–∞–≤–ª—è–µ–º –∞–≥–µ–Ω—Ç–∞ –≤ –∫–æ–Ω—Ç–µ–Ω—Ç
                    agent_section = f"\n- **{agent_id}** ({role or 'worker'}) - –¥–æ–±–∞–≤–ª–µ–Ω {datetime.now().strftime('%H:%M:%S')}"
                    
                    if "## –ê–≥–µ–Ω—Ç—ã" in note.content:
                        note.content = note.content.replace(
                            "*–ê–≥–µ–Ω—Ç—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏*",
                            agent_section.strip()
                        )
                        if agent_section not in note.content:
                            # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ —Å–µ–∫—Ü–∏–∏ –∞–≥–µ–Ω—Ç–æ–≤
                            note.content = note.content.replace("## –ê–≥–µ–Ω—Ç—ã", f"## –ê–≥–µ–Ω—Ç—ã{agent_section}")
                    
                    # –°–æ–∑–¥–∞—ë–º —Å–≤—è–∑—å —Å —Ä–∞–±–æ—á–∏–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ–º –∞–≥–µ–Ω—Ç–∞
                    self.db.create_link(Path(note_info["path"]).stem, f"agents/{agent_id}", f"–ê–≥–µ–Ω—Ç {agent_id}")
                    
                    self.db.save_note(note, Path(note_info["path"]).name)
                    logger.info(f"ü§ñ –ê–≥–µ–Ω—Ç {agent_id} –¥–æ–±–∞–≤–ª–µ–Ω –∫ –∑–∞–¥–∞—á–µ {task_id}")
                    break
    
    def add_result_to_task(self, task_id: str, agent_id: str, result_content: str, result_type: str = "result"):
        """–î–æ–±–∞–≤–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞–≥–µ–Ω—Ç–∞ –∫ –∑–∞–¥–∞—á–µ"""
        task_notes = self.db.search_notes(metadata_filter={"task_id": task_id})
        
        for note_info in task_notes:
            if note_info["metadata"].get("folder") == "tasks":
                note = self.db.get_note(note_info["path"])
                if note:
                    # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∫–æ–Ω—Ç–µ–Ω—Ç
                    timestamp = datetime.now().strftime('%H:%M:%S')
                    result_section = f"""
### {agent_id} - {result_type} ({timestamp})

{result_content[:300]}{"..." if len(result_content) > 300 else ""}

[[{agent_id}_{result_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}|–ü–æ–ª–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç]]
"""
                    
                    if "## –†–µ–∑—É–ª—å—Ç–∞—Ç—ã" in note.content:
                        note.content = note.content.replace(
                            "*–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ –º–µ—Ä–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è*",
                            result_section.strip()
                        )
                        if result_section not in note.content:
                            # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ —Å–µ–∫—Ü–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                            note.content = note.content.replace("## –†–µ–∑—É–ª—å—Ç–∞—Ç—ã", f"## –†–µ–∑—É–ª—å—Ç–∞—Ç—ã{result_section}")
                    
                    self.db.save_note(note, Path(note_info["path"]).name)
                    logger.info(f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç {agent_id} –¥–æ–±–∞–≤–ª–µ–Ω –∫ –∑–∞–¥–∞—á–µ {task_id}")
                    break
    
    def get_task_summary(self, task_id: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∞–µ—Ç —Å–≤–æ–¥–∫—É –ø–æ –∑–∞–¥–∞—á–µ"""
        # –û—Å–Ω–æ–≤–Ω–∞—è –∑–∞–º–µ—Ç–∫–∞ –∑–∞–¥–∞—á–∏
        task_notes = self.db.search_notes(metadata_filter={"task_id": task_id})
        task_note = None
        
        for note_info in task_notes:
            if note_info["metadata"].get("folder") == "tasks":
                task_note = note_info
                break
        
        if not task_note:
            return {"error": f"–ó–∞–¥–∞—á–∞ {task_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"}
        
        # –í—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∑–∞–º–µ—Ç–∫–∏
        all_related = self.db.search_notes(metadata_filter={"task_id": task_id})
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Ç–∏–ø–∞–º
        agents = []
        results = []
        coordination = []
        
        for note_info in all_related:
            folder = note_info["metadata"].get("folder", "")
            if folder == "agents":
                agents.append({
                    "agent_id": note_info["metadata"].get("agent_id"),
                    "result_type": note_info["metadata"].get("result_type"),
                    "timestamp": note_info["updated"]
                })
            elif folder == "coordination":
                coordination.append({
                    "from_agent": note_info["metadata"].get("from_agent"),
                    "to_agent": note_info["metadata"].get("to_agent"),
                    "timestamp": note_info["updated"]
                })
        
        return {
            "task_id": task_id,
            "title": task_note["title"],
            "status": task_note["metadata"].get("status", "unknown"),
            "created": task_note["created"],
            "updated": task_note["updated"],
            "agents_count": len(set(a["agent_id"] for a in agents if a["agent_id"])),
            "results_count": len([a for a in agents if a["result_type"] == "result"]),
            "coordination_messages": len(coordination),
            "agents": agents,
            "coordination": coordination
        }

def get_obsidian_db(vault_path: str = "./obsidian_vault") -> ObsidianDB:
    """–ü–æ–ª—É—á–∞–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä ObsidianDB"""
    if not hasattr(get_obsidian_db, '_instance'):
        get_obsidian_db._instance = ObsidianDB(vault_path)
    return get_obsidian_db._instance

def create_agent_workspace(agent_id: str, vault_path: str = "./obsidian_vault") -> AgentWorkspace:
    """–°–æ–∑–¥–∞—ë—Ç —Ä–∞–±–æ—á–µ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∞–≥–µ–Ω—Ç–∞"""
    db = get_obsidian_db(vault_path)
    return AgentWorkspace(agent_id, db)

def create_task_manager(vault_path: str = "./obsidian_vault") -> TaskManager:
    """–°–æ–∑–¥–∞—ë—Ç –º–µ–Ω–µ–¥–∂–µ—Ä –∑–∞–¥–∞—á"""
    db = get_obsidian_db(vault_path)
    return TaskManager(db) 