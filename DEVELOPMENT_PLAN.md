# План разработки универсальной платформы ИИ-агентов

---

## Общие инструменты и подходы

### Технологический стек
- Backend: Python 3.11+, FastAPI (основной REST API), Pydantic, Celery (асинхронные задачи), MongoDB (основная БД), Redis (брокер очередей, кэш), PostgreSQL (аналитика, опционально).
- Frontend: React (Next.js), TypeScript, Ant Design/MUI (UI), BPMN.js (визуализация сценариев), Redux Toolkit (стейт-менеджмент).
- Интеграции: OpenAI/OpenRouter (LLM), внешние REST/gRPC API, amoCRM, RAG-сервисы, email, webhooks.
- Контейнеризация и деплой: Docker, docker-compose (локально), Kubernetes (k8s, Helm charts), GitHub Actions (CI/CD), Prometheus+Grafana (мониторинг), ELK/Graylog (логи).

### Архитектурные принципы
- Микросервисная архитектура, слабое связывание компонентов.
- API-first: все сервисы проектируются через OpenAPI/Swagger.
- Конфигурируемость через БД/конфиги, минимум хардкода.
- Расширяемость через плагины и интеграции.
- Логирование и аудит по единому стандарту (JSON-логи, отдельные файлы в logs/ по сервисам и типам событий).
- Безопасность по принципу наименьших привилегий (RBAC, шифрование, 2FA, регулярные бэкапы).

## Заимствования и использование опенсорс-решений

В рамках разработки платформы рекомендуется активно использовать лучшие практики и готовые модули из ведущих опенсорс-проектов:

- **LangChain** — для ядра работы с LLM, построения сценариев, интеграций с внешними сервисами, реализации плагинной архитектуры.
- **SuperAGI** — как источник архитектурных решений для управления агентами, UI, системы плагинов и RBAC.
- **Flowise** и **BPMN.js** — для визуального редактора сценариев и BPMN-диаграмм в админке.
- **Haystack** — для реализации RAG (retrieval-augmented generation) и поиска по корпоративным данным.
- **Ant Design/MUI** — для UI-компонентов фронтенда.
- **CI/CD, тестирование, логирование** — использовать лучшие практики из workflow указанных проектов (GitHub Actions, pytest, coverage, structured logging).

### Принципы заимствования
- Использовать готовые модули и библиотеки там, где это возможно без потери гибкости и безопасности.
- Не пытаться «склеить» проекты напрямую, а строить собственную архитектуру, заимствуя отдельные компоненты и подходы.
- При необходимости — форкать наиболее близкие по архитектуре проекты (например, SuperAGI) и дорабатывать их под свои нужды.
- Все заимствованные компоненты должны быть адаптированы под единую модель данных, стандарты логирования, мониторинга и безопасности платформы.
- В документации фиксировать источник и назначение каждого заимствованного решения.

### Примеры заимствований
- Интерфейсы плагинов и интеграций — по аналогии с LangChain и SuperAGI.
- Визуальный редактор сценариев — на базе Flowise или BPMN.js.
- Механизмы логирования и мониторинга — по примеру Haystack и SuperAGI (JSON-логи, Prometheus, Grafana).
- Примеры workflow для CI/CD — из LangChain, Haystack.
- Библиотека готовых сценариев и агентов — по аналогии с SuperAGI и LangChain.

### Что требует самостоятельной доработки
- Единая модель данных (User, Agent, Scenario, Step, Context, Integration, Trigger).
- Централизованная авторизация, аудит, RBAC, безопасность.
- Унификация логирования, мониторинга, админки и API gateway.
- Глубокая интеграция между backend и frontend, поддержка мультиязычности.
- Документация, onboarding, поддержка и сопровождение.

### Стандарты разработки
- Code style: black, isort, flake8 (Python), eslint/prettier (JS/TS).
- Документирование кода: docstrings (Google style), автогенерация Swagger/OpenAPI.
- Покрытие тестами: pytest (unit/integration), coverage >80%, e2e-тесты для ключевых сценариев.
- CI/CD: автоматический запуск тестов, линтеров, сборка и деплой через GitHub Actions.
- Версионирование: git-flow, semantic versioning, changelog.

### Логирование и мониторинг
- Все сервисы пишут логи в папку logs/ (по типу: errors, audit, integration, events и т.д.).
- Централизованный сбор логов через ELK/Graylog.
- Метрики и алерты через Prometheus+Grafana.
- Логи тестов — в logs/unit_tests.log, logs/integration_tests.log и др.

### Документация и поддержка
- Вся документация хранится в docs/ и публикуется через mkdocs или аналог.
- Автогенерация OpenAPI/Swagger для всех API.
- Примеры сценариев, шаблоны, гайды — отдельными файлами и в админке.
- Регулярное обновление и версионирование документации.

## Чек-листы и шаблоны

### Чек-лист: Новый микросервис
- [ ] Создан репозиторий/папка сервиса
- [ ] Описан requirements.txt/pyproject.toml с зависимостями
- [ ] Настроен Dockerfile и docker-compose.yml
- [ ] Реализован healthcheck endpoint
- [ ] Описан OpenAPI/Swagger для всех эндпоинтов
- [ ] Настроено логирование в logs/<service>.log
- [ ] Подключён централизованный сбор логов
- [ ] Покрытие тестами >80% (unit/integration)
- [ ] Настроен CI/CD pipeline (lint, test, build, deploy)
- [ ] Документация в docs/ и README.md

### Чек-лист: Новая интеграция/плагин
- [ ] Описан интерфейс плагина (метаданные, точки входа)
- [ ] Реализована регистрация и инициализация
- [ ] Реализована обработка ошибок и fallback
- [ ] Добавлены примеры использования
- [ ] Покрытие тестами >80%
- [ ] Документация по настройке и использованию

### Чек-лист: Новый сценарий/агент
- [ ] Описан сценарий в формате JSON/YAML/BPMN
- [ ] Протестированы все ветвления и переходы
- [ ] Настроены промты и локализации
- [ ] Проверена интеграция с LLM/RAG/CRM
- [ ] Добавлен шаблон в библиотеку сценариев
- [ ] Описан use case и инструкция для админки

### Чек-лист: Тесты
- [ ] Unit-тесты для всех ключевых функций
- [ ] Интеграционные тесты для API и интеграций
- [ ] E2E-тесты для пользовательских сценариев
- [ ] Логи тестов в logs/unit_tests.log, logs/integration_tests.log
- [ ] Покрытие тестами >80%

---

### Шаблон: requirements.txt (Python сервис)
```
fastapi
uvicorn
pydantic
motor
celery
redis
pytest
pytest-cov
black
isort
flake8
python-dotenv
loguru
```

### Шаблон: Dockerfile
```
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### Шаблон: docker-compose.yml (фрагмент)
```
version: '3.8'
services:
  service:
    build: .
    ports:
      - "8000:8000"
    env_file:
      - .env
    depends_on:
      - mongo
      - redis
  mongo:
    image: mongo:6
    ports:
      - "27017:27017"
  redis:
    image: redis:7
    ports:
      - "6379:6379"
```

### Шаблон: README.md (фрагмент)
```
# Название сервиса

## Описание
Краткое описание назначения сервиса.

## Быстрый старт
```bash
git clone ...
cd ...
docker-compose up --build
```

## Переменные окружения
- MONGO_URI=...
- REDIS_URL=...
- ...

## Документация API
Swagger: http://localhost:8000/docs

## Тесты
```bash
pytest --cov
```
```

### Шаблон: plugin.py (интерфейс плагина)
```
class PluginBase:
    def __init__(self, config):
        self.config = config
    def on_event(self, event):
        pass
    def healthcheck(self):
        return True
```

---

## Детализация заимствований: ссылки, примеры, версии

### LangChain
- **Документация:**  
  https://python.langchain.com/docs/
- **Рекомендуемая версия:**  
  langchain>=0.1.0
- **Примеры:**
  - [Custom Tools (плагины)](https://python.langchain.com/docs/modules/agents/tools/custom_tools/)
  - [Интеграция с LLM](https://python.langchain.com/docs/integrations/llms/)
  - [Примеры сценариев](https://github.com/langchain-ai/langchain/tree/master/examples)
- **Что заимствовать:**
  - Интерфейсы плагинов (Tools, Agents)
  - Примеры интеграции с OpenAI, HuggingFace, RAG
  - Структуру сценариев (chains, agents)

#### Пример кастомного инструмента LangChain (Python)
```python
from langchain.tools import BaseTool

class MyCustomTool(BaseTool):
    name = "my_tool"
    description = "Описание вашего инструмента"
    def _run(self, input_str: str):
        # Ваша логика
        return f"Результат: {input_str}"
```
[Документация по кастомным инструментам](https://python.langchain.com/docs/modules/agents/tools/custom_tools/)

---

### SuperAGI
- **Документация:**  
  https://docs.superagi.com/
- **Рекомендуемая версия:**  
  superagi>=0.0.16
- **Примеры:**
  - [GitHub репозиторий](https://github.com/TransformerOptimus/SuperAGI)
  - [Каталог плагинов](https://github.com/TransformerOptimus/SuperAGI/tree/main/superagi/tools)
- **Что заимствовать:**
  - Архитектуру управления агентами
  - Примеры UI-админки
  - RBAC, систему плагинов

---

### Flowise
- **Документация:**  
  https://docs.flowiseai.com/
- **Рекомендуемая версия:**  
  flowise>=1.3.0
- **Примеры:**
  - [GitHub репозиторий](https://github.com/FlowiseAI/Flowise)
  - [Визуальный редактор сценариев](https://flowiseai.com/)
- **Что заимствовать:**
  - Визуальный редактор сценариев (можно интегрировать как iframe или через API)
  - Примеры BPMN-диаграмм

---

### BPMN.js
- **Документация:**  
  https://bpmn.io/toolkit/bpmn-js/
- **Рекомендуемая версия:**  
  bpmn-js@11.5.0
- **Примеры:**
  - [Пример интеграции с React](https://github.com/bpmn-io/react-bpmn)
- **Что заимствовать:**
  - Визуализация и редактирование бизнес-процессов в админке

#### Пример BPMN.js в React
```jsx
import BpmnJS from 'bpmn-js';
import React, { useEffect, useRef } from 'react';

export default function BpmnEditor({ xml }) {
  const ref = useRef(null);
  useEffect(() => {
    const bpmnViewer = new BpmnJS({ container: ref.current });
    bpmnViewer.importXML(xml);
    return () => bpmnViewer.destroy();
  }, [xml]);
  return <div ref={ref} style={{ height: 500 }} />;
}
```
[Пример интеграции](https://github.com/bpmn-io/react-bpmn)

---

### Haystack
- **Документация:**  
  https://docs.haystack.deepset.ai/
- **Рекомендуемая версия:**  
  farm-haystack>=1.23.0
- **Примеры:**
  - [Интеграция с LLM и RAG](https://docs.haystack.deepset.ai/docs/llm)
  - [Retriever API](https://docs.haystack.deepset.ai/docs/retriever)
- **Что заимствовать:**
  - RAG-модули, примеры поиска по корпоративным данным
  - Примеры логирования и мониторинга

---

### Ant Design / MUI
- **Ant Design:**
  - Документация: https://ant.design/docs/react/introduce
  - Версия: antd@5.13.0
- **MUI:**
  - Документация: https://mui.com/material-ui/getting-started/
  - Версия: @mui/material@5.15.0
- **Что заимствовать:**
  - Готовые UI-компоненты для админки и форм

---

### CI/CD, тестирование, логирование

- **GitHub Actions:**
  - Документация: https://docs.github.com/en/actions
  - Пример workflow для Python:  
    [LangChain CI](https://github.com/langchain-ai/langchain/blob/master/.github/workflows/ci.yml)
- **pytest:**
  - Документация: https://docs.pytest.org/en/stable/
  - Версия: pytest>=7.4.0
- **loguru:**
  - Документация: https://loguru.readthedocs.io/en/stable/
  - Версия: loguru>=0.7.0
- **Prometheus Python client:**
  - Документация: https://github.com/prometheus/client_python
  - Версия: prometheus-client>=0.17.0
- **ELK Stack:**
  - Документация: https://www.elastic.co/guide/en/elastic-stack-get-started/current/get-started-elastic-stack.html

#### Пример логирования с loguru
```python
from loguru import logger

logger.add("logs/api.log", format="{time} {level} {message}", level="INFO", rotation="10 MB", compression="zip", serialize=True)
logger.info("Сервис запущен")
```
[Документация loguru](https://loguru.readthedocs.io/en/stable/)

#### Пример Prometheus metrics в FastAPI
```python
from prometheus_client import Counter, start_http_server

REQUEST_COUNT = Counter('request_count', 'Total number of requests')
start_http_server(8001)

@app.middleware("http")
async def prometheus_middleware(request, call_next):
    REQUEST_COUNT.inc()
    response = await call_next(request)
    return response
```
[Документация Prometheus Python client](https://github.com/prometheus/client_python)

#### Пример workflow для GitHub Actions (Python)
```yaml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install dependencies
        run: pip install -r requirements.txt
      - name: Lint
        run: flake8 .
      - name: Test
        run: pytest --cov
```
[Пример workflow LangChain](https://github.com/langchain-ai/langchain/blob/master/.github/workflows/ci.yml)

---

### FastAPI
- **Документация:** https://fastapi.tiangolo.com/
- **Рекомендуемая версия:** fastapi>=0.110.0
- **Пример базового приложения:**
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/health")
def health():
    return {"status": "ok"}
```

---

### Celery
- **Документация:** https://docs.celeryq.dev/en/stable/
- **Рекомендуемая версия:** celery>=5.3.6
- **Пример задачи:**
```python
from celery import Celery

app = Celery('tasks', broker='redis://localhost:6379/0')

@app.task
def add(x, y):
    return x + y
```

---

### MongoDB (motor)
- **Документация:** https://motor.readthedocs.io/en/stable/
- **Рекомендуемая версия:** motor>=3.3.2
- **Пример подключения:**
```python
import motor.motor_asyncio

client = motor.motor_asyncio.AsyncIOMotorClient('mongodb://localhost:27017')
db = client['mydatabase']
```

---

### Redis (aioredis)
- **Документация:** https://aioredis.readthedocs.io/en/latest/
- **Рекомендуемая версия:** aioredis>=2.0.1
- **Пример подключения:**
```python
import aioredis

redis = await aioredis.create_redis_pool('redis://localhost')
await redis.set('my-key', 'value')
value = await redis.get('my-key', encoding='utf-8')
```

---

### Пример unit-теста с pytest
```python
def test_add():
    assert 1 + 1 == 2
```

---

### Пример e2e-теста FastAPI с httpx
```python
from fastapi.testclient import TestClient
from main import app

def test_health():
    client = TestClient(app)
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "ok"}
```

---

### Пример docker-compose для локального запуска
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8000:8000"
    env_file:
      - .env
    depends_on:
      - mongo
      - redis
  mongo:
    image: mongo:6
    ports:
      - "27017:27017"
  redis:
    image: redis:7
    ports:
      - "6379:6379"
```

---

### Пример pre-commit конфига для Python
```yaml
repos:
  - repo: https://github.com/psf/black
    rev: 23.12.1
    hooks:
      - id: black
  - repo: https://github.com/PyCQA/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pycqa/flake8
    rev: 7.0.0
    hooks:
      - id: flake8
```

---

### Пример pre-commit конфига для JS/TS
```yaml
repos:
  - repo: https://github.com/prettier/prettier
    rev: 3.2.5
    hooks:
      - id: prettier
  - repo: https://github.com/pre-commit/mirrors-eslint
    rev: v8.56.0
    hooks:
      - id: eslint
```

---

## 1. Архитектурное проектирование

### 1.1. Выбор стека и инфраструктуры
- Оценить требования к нагрузке, масштабируемости, интеграциям.
- Выбрать стек: Python (FastAPI/Flask), MongoDB/Postgres, Celery/Redis, React/Next.js.
- Описать требования к деплою (docker-compose, k8s, CI/CD).
- Составить список внешних сервисов для интеграции (LLM, RAG, CRM и др.).

### 1.2. Проработка основных сущностей
- Описать модели: User, Agent, Scenario, Step, Context, Integration, Trigger.
- Нарисовать ER-диаграмму и схему связей.
- Определить минимальные поля и индексы для каждой сущности.
- Согласовать структуру хранения сценариев и шагов (JSON, отдельные коллекции, связи).

### 1.3. Схема взаимодействия компонентов
- Нарисовать sequence diagram: пользователь → ядро → БД → интеграции → админка.
- Описать точки интеграции с внешними сервисами (LLM, RAG, CRM и др.).
- Определить API-гейтвей и маршрутизацию сообщений.
- Согласовать протоколы взаимодействия между backend и frontend (REST, WebSocket, GraphQL).

---

## 2. Ядро платформы (backend)

### 2.1. Реализация моделей и БД
- Реализовать модели (ORM/ODM): User, Agent, Scenario, Step, Context, Integration, Trigger.
- Настроить миграции и тестовые данные.
- Реализовать версионирование сценариев и промтов.
- Протестировать базовые CRUD-операции для всех сущностей.

### 2.2. CRUD и API для управления
- Реализовать REST API для агентов, сценариев, шагов (создание, чтение, обновление, удаление).
- Реализовать API для запуска агента (по команде, событию, расписанию).
- Реализовать API для получения/обновления контекста пользователя.
- Реализовать API для интеграций (RAG, LLM, внешние сервисы).
- Покрыть API автотестами (unit/integration).

### 2.3. Ядро исполнения сценариев
- Реализовать state machine для сценариев (управление переходами между шагами).
- Реализовать механизм триггеров (on_command, on_schedule, on_event, on_internal_trigger).
- Реализовать смысловую валидацию и генерацию ответа (интеграция с LLM, шаблоны, плагины).
- Реализовать хуки/middleware для расширения логики (логирование, аудит, модификация контекста).
- Протестировать сценарии с разными типами шагов и переходов.

### 2.4. Хранение и синхронизация данных
- Настроить локальную БД для каждого инстанса (скорость, надёжность).
- Реализовать асинхронную синхронизацию с общей БД (аналитика, кросс-агентные сценарии).
- Реализовать хранение истории, контекста, версий сценариев.
- Реализовать резервное копирование и восстановление данных.

---

## 3. Админка (frontend)

### 3.1. Список агентов и блоков
- Реализовать страницу со списком всех агентов и блоков (групп агентов).
- Реализовать фильтрацию, поиск, сортировку агентов.
- Реализовать создание нового агента/блока через форму.
- Реализовать удаление и объединение агентов в блоки (drag-and-drop или через меню).
- Реализовать просмотр статуса агента (активен/неактивен, версия сценария, дата обновления).

### 3.2. Графический редактор сценариев
- Реализовать drag-and-drop редактор шагов сценария (flowchart/BPMN).
- Реализовать добавление/удаление/редактирование шагов через UI.
- Для каждого шага реализовать настройку:
  - Тип шага (промт-валидация-промт, промт-валидация-триггер и др.)
  - Промты и варианты сообщений (мультиязычность)
  - Условия перехода, ветвления (if/else, switch-case)
  - Переменные сценария (создание, использование, подстановка)
  - Используемый контекст (выбор данных из БД, внешних сервисов)
  - Интеграции (выбор модели, вызовы внешних сервисов)
  - Действие по завершении шага (триггер, переход, вызов другого агента)
  - Fallback-логика (поведение при ошибках)
- Реализовать визуализацию структуры сценария (граф переходов, BPMN-диаграмма).
- Реализовать симуляцию сценария (тестовый прогон с возможностью "пройти" сценарий как пользователь).

### 3.3. Управление версиями и A/B тестами
- Реализовать хранение истории изменений сценария (versioning).
- Реализовать просмотр, сравнение и откат версий сценария.
- Реализовать создание альтернативных версий сценария для A/B тестирования.
- Реализовать выбор активной версии сценария для каждого агента.

### 3.4. Экспорт/импорт сценариев
- Реализовать экспорт сценария в форматах JSON/YAML/BPMN.
- Реализовать импорт сценария из файла (с валидацией структуры).
- Реализовать библиотеку шаблонов сценариев (быстрый старт для новых агентов).

### 3.5. Права доступа и роли
- Реализовать систему аутентификации и авторизации пользователей админки.
- Реализовать разграничение доступа по ролям (админ, редактор, наблюдатель).
- Реализовать аудит действий пользователей в админке (логирование изменений, действий, входов/выходов).

---

## 4. Интеграции и плагины

### 4.1. Базовые интеграции
- Реализовать интеграцию с LLM (OpenAI/OpenRouter):
  - Настроить API-клиент, параметры, обработку ошибок.
  - Реализовать выбор модели и проксирование запросов из сценариев.
  - Реализовать логирование всех LLM-запросов (logs/llm_integration.log).
- Реализовать интеграцию с RAG (Retrieval-Augmented Generation):
  - Настроить подключение к базе знаний/поисковому сервису.
  - Реализовать обработку запросов к RAG из сценариев.
  - Реализовать логирование обращений к RAG (logs/rag_integration.log).
- Реализовать интеграцию с CRM (например, amoCRM):
  - Реализовать создание/обновление контактов, лидов, заметок.
  - Реализовать синхронизацию данных пользователя при изменениях.
  - Реализовать логирование интеграции с CRM (logs/crm_integration.log).
- Реализовать интеграцию с mindmap/graph-сервисами (опционально):
  - Настроить API-клиент, реализовать базовые операции (создание, обновление, получение данных).

### 4.2. API для подключения новых интеграций (плагины)
- Разработать универсальный интерфейс для подключения новых интеграций (plugin API):
  - Описать структуру плагина (метаданные, точки входа, обработчики событий).
  - Реализовать регистрацию и инициализацию плагинов при старте платформы.
  - Реализовать механизм передачи данных между ядром и плагинами (events, hooks).
  - Реализовать обработку ошибок и fallback для плагинов.
- Реализовать документацию и примеры для разработчиков плагинов.

### 4.3. Механизм событий и подписок
- Реализовать pub/sub-механизм для событий платформы:
  - Описать основные типы событий (user_created, scenario_step_completed, external_call и др.).
  - Реализовать подписку плагинов и внешних сервисов на события.
  - Реализовать публикацию событий из ядра платформы.
  - Реализовать логирование событий (logs/events.log).
- Реализовать webhook-интерфейс для внешних подписчиков:
  - Реализовать настройку webhook-URL через админку.
  - Реализовать отправку событий по HTTP(S) с retry и логированием.

---

## 5. Механизмы запуска и масштабирования

### 5.1. Запуск агентов по триггерам
- Реализовать поддержку запуска агентов по команде пользователя (on_command):
  - Описать структуру команд, реализовать парсер команд.
  - Реализовать обработку команд из разных каналов (Telegram, web, API).
- Реализовать запуск по событию (on_event):
  - Описать типы событий, реализовать подписку на события.
  - Реализовать обработку внешних событий (webhook, pub/sub).
- Реализовать запуск по расписанию (on_schedule):
  - Настроить планировщик задач (Celery beat, APScheduler или аналог).
  - Реализовать хранение и управление расписаниями через админку.
  - Реализовать логику повторяющихся и отложенных запусков.
- Реализовать логирование всех запусков агентов (logs/agent_launch.log).

### 5.2. Очереди задач и асинхронные операции
- Настроить брокер очередей (Redis, RabbitMQ) и worker'ы (Celery, RQ).
- Реализовать асинхронное выполнение долгих операций (интеграции, генерация, синхронизация).
- Реализовать мониторинг состояния очередей и задач (Flower, custom dashboard).
- Реализовать обработку ошибок и повторные попытки (retry, dead letter queue).
- Реализовать логирование задач очереди (logs/task_queue.log).

### 5.3. Горизонтальное масштабирование
- Подготовить docker-compose для локального и тестового запуска.
- Подготовить Helm chart или манифесты для деплоя в k8s (Kubernetes).
- Реализовать автоматическое масштабирование worker'ов и сервисов (k8s HPA, custom logic).
- Реализовать health-check и readiness/liveness probes для всех сервисов.
- Реализовать централизованное логирование и сбор метрик (Prometheus, Grafana, ELK).
- Реализовать резервное копирование и восстановление состояния очередей и БД.

---

## 6. Мультиканальность и локализация

### 6.1. Универсальный входящий интерфейс
- Реализовать абстракцию входящего сообщения (Message/Event), поддерживающую все каналы (Telegram, web, email, API).
- Реализовать адаптеры для каждого канала:
  - Telegram: интеграция с Bot API, поддержка команд, кнопок, вложений.
  - Web: REST/WebSocket API для чата, поддержка авторизации, вложений.
  - Email: интеграция с почтовым сервером (IMAP/SMTP), парсинг писем.
  - API: REST/gRPC endpoint для внешних систем.
- Реализовать маршрутизацию сообщений к нужному агенту/сценарию по каналу и идентификатору пользователя.
- Реализовать логирование всех входящих/исходящих сообщений (logs/messages.log).

### 6.2. Локализация промтов и сценариев
- Реализовать хранение промтов и сообщений на нескольких языках (структура: lang → prompt_id → текст).
- Реализовать определение языка пользователя (по профилю, настройкам, автоопределение).
- Реализовать выбор языка сценария и сообщений на лету (переключение в процессе диалога).
- Реализовать поддержку мультиязычных сценариев (ветвления по языку, fallback на дефолтный язык).
- Реализовать инструменты для перевода и валидации локализаций (экспорт/импорт переводов, автопроверка completeness).
- Реализовать логирование ошибок локализации (logs/locale_errors.log).

---

## 7. Аудит, аналитика, безопасность

### 7.1. Аудит и логирование
- Реализовать централизованное логирование всех действий, событий, переходов (logs/audit.log).
- Реализовать аудит изменений сценариев, настроек, данных пользователей (кто, когда, что изменил).
- Реализовать хранение истории входов/выходов пользователей админки.
- Реализовать инструменты поиска и фильтрации логов (по пользователю, агенту, дате, типу события).
- Реализовать экспорт логов для анализа и расследований.

### 7.2. Аналитика
- Реализовать сбор метрик по сценариям (количество запусков, успешных/ошибочных переходов, среднее время шага и т.д.).
- Реализовать аналитику по эффективности агентов (конверсии, drop-off, пользовательские пути).
- Реализовать дешборды для визуализации метрик (Grafana, custom dashboard).
- Реализовать экспорт аналитических данных (CSV, Excel, API).
- Реализовать алерты по аномалиям и сбоям (email, Telegram, Slack).

### 7.3. Права и доступы, безопасность данных
- Реализовать разграничение прав доступа (RBAC): роли, группы, индивидуальные разрешения.
- Реализовать аутентификацию пользователей (OAuth2, JWT, SSO, 2FA).
- Реализовать аудит доступа к чувствительным данным (кто и когда просматривал/изменял).
- Реализовать шифрование данных в покое и при передаче (TLS, AES).
- Реализовать защиту от типовых атак (CSRF, XSS, brute force, rate limiting).
- Реализовать регулярные бэкапы и тестирование восстановления данных.
- Реализовать журналирование попыток несанкционированного доступа и автоматические блокировки.

---

## 8. MVP-итерация (минимально жизнеспособный продукт)

### 8.1. Ядро исполнения сценариев
- Реализовать базовый state machine для сценариев (минимум: линейная последовательность шагов).
- Реализовать поддержку промтов, валидации и генерации ответов через LLM.
- Реализовать хранение и обновление контекста пользователя в ходе сценария.
- Реализовать обработку ошибок и fallback-логику для шагов.

### 8.2. CRUD для агентов, сценариев, шагов (REST API)
- Реализовать REST API для создания, чтения, обновления, удаления агентов, сценариев, шагов.
- Реализовать базовую валидацию входных данных.
- Реализовать автотесты для основных API-методов.

### 8.3. Простая админка для сценариев
- Реализовать web-интерфейс (React/Next.js) для создания и редактирования сценариев.
- Реализовать просмотр списка агентов и сценариев.
- Реализовать добавление/удаление/редактирование шагов сценария через UI.

### 8.4. Интеграция с одним LLM (например, OpenAI)
- Настроить API-клиент для выбранного LLM.
- Реализовать проксирование запросов к LLM из сценариев.
- Реализовать логирование всех LLM-запросов (logs/llm_integration.log).

### 8.5. Запуск по команде и событию
- Реализовать запуск сценария по команде пользователя (on_command).
- Реализовать запуск по внешнему событию (on_event, например, webhook).
- Реализовать логирование всех запусков (logs/agent_launch.log).

### 8.6. Локальное хранение данных, простая синхронизация
- Реализовать хранение данных пользователей, сценариев, истории в локальной БД.
- Реализовать простую синхронизацию с общей БД (например, периодический экспорт/импорт).
- Реализовать резервное копирование данных.

### 8.7. Логирование и базовая аналитика
- Реализовать централизованное логирование действий и ошибок (logs/audit.log, logs/errors.log).
- Реализовать сбор базовых метрик (количество запусков, ошибок, пользователей).
- Реализовать простую страницу/отчёт с базовой аналитикой (количество сценариев, агентов, запусков).

---

## 9. Расширение и масштабирование

### 9.1. Новые типы триггеров
- Реализовать поддержку запуска сценариев по расписанию (on_schedule) с гибкой настройкой cron/таймеров.
- Реализовать поддержку внешних событий (on_event) через webhook/pubsub.
- Реализовать внутренние триггеры (on_internal_trigger) для сложных сценариев и автоматизации.
- Реализовать визуальный редактор для настройки триггеров в админке.

### 9.2. Подключение новых интеграций
- Реализовать интеграцию с новыми LLM, RAG, CRM, mindmap и другими сервисами через плагин-интерфейс.
- Реализовать marketplace/каталог плагинов для быстрой установки новых интеграций.
- Реализовать инструменты для тестирования и отладки интеграций.

### 9.3. Расширение админки
- Реализовать поддержку сложных ветвлений сценариев (if/else, switch-case, условия по переменным).
- Реализовать симуляцию сценариев с разными путями пользователя.
- Реализовать A/B тестирование сценариев с автоматическим сбором статистики.
- Реализовать расширенные права доступа (разграничение по агентам, сценариям, действиям).

### 9.4. Мультиканальность, локализация, экспорт/импорт
- Реализовать поддержку новых каналов (WhatsApp, Viber, VK, голосовые ассистенты и др.).
- Реализовать расширенную локализацию (поддержка новых языков, автоперевод, редактор переводов).
- Реализовать экспорт/импорт сценариев и данных в новых форматах (BPMN, YAML, CSV).

### 9.5. Масштабирование и отказоустойчивость
- Реализовать автоматическое масштабирование сервисов и очередей под нагрузкой (k8s HPA, custom logic).
- Реализовать балансировку нагрузки между инстансами агентов.
- Реализовать отказоустойчивое хранение данных (репликация, резервные кластеры).
- Реализовать автоматическое восстановление сервисов при сбоях (self-healing, restart policies).
- Реализовать мониторинг SLA и автоматические алерты по деградации.

---

## 10. Документация и поддержка

### 10.1. Документация по API, сценариям, интеграциям
- Реализовать автогенерацию и публикацию OpenAPI/Swagger для всех REST API.
- Описать структуру сценариев, шагов, триггеров, интеграций (с примерами JSON/YAML/BPMN).
- Поддерживать актуальность документации при изменениях моделей и API.
- Реализовать версионирование документации (history, changelog).
- Реализовать поиск по документации и быстрые ссылки на примеры.

### 10.2. Гайды для админов и разработчиков
- Подготовить пошаговые гайды по настройке агентов, созданию сценариев, интеграции новых сервисов.
- Описать типовые сценарии использования платформы (use cases, best practices).
- Реализовать раздел FAQ и troubleshooting для типовых проблем.
- Реализовать видео- и скринкаст-инструкции для ключевых функций.

### 10.3. Примеры сценариев и шаблоны
- Подготовить библиотеку готовых сценариев для разных задач (опросы, диагностика, рекомендации и др.).
- Реализовать шаблоны для быстрого старта новых агентов и сценариев.
- Реализовать экспорт/импорт шаблонов через админку.
- Поддерживать актуальность и расширяемость библиотеки примеров.

---

## Атомарные задачи для ускоренной генерации MVP

### Backend (FastAPI, MongoDB, Celery) — микрозадачи

#### 1. Базовая структура и окружение
- [ ] Сгенерировать структуру FastAPI-проекта (cookiecutter, шаблон)
- [ ] Создать requirements.txt с минимальным набором зависимостей
- [ ] Создать Dockerfile (базовый, без оптимизаций)
- [ ] Создать docker-compose.yml с сервисами: app, mongo, redis
- [ ] Добавить .env.example с переменными окружения
- [ ] Включить автоматические проверки обновлений зависимостей (Dependabot, Renovate)
- [ ] Настроить автоматическую проверку на наличие уязвимостей в зависимостях (safety, Snyk)
- [ ] Добавить smoke-тесты на совместимость при обновлении зависимостей

#### 2. Модели (Pydantic + MongoDB)
- [ ] Описать Pydantic-модель User (id, name, email, created_at)
- [ ] Описать Pydantic-модель Agent (id, name, config, created_at)
- [ ] Описать Pydantic-модель Scenario (id, name, steps, created_at)
- [ ] Создать MongoDB-репозиторий для User
- [ ] Создать MongoDB-репозиторий для Agent
- [ ] Создать MongoDB-репозиторий для Scenario
- [ ] Внедрить систему миграций для MongoDB (Mongock или custom scripts)
- [ ] Добавить автоматическую проверку схемы БД при деплое
- [ ] E2E-тест: деплой с миграцией на чистую и существующую БД

#### 3. CRUD endpoints (User)
- [ ] Описать схему запроса для POST /users (Pydantic)
- [ ] Описать схему ответа для POST /users
- [ ] Реализовать POST /users (валидация, запись в БД)
- [ ] Обработать DuplicateKeyError (409)
- [ ] Добавить логирование успешного и неуспешного создания пользователя
- [ ] Добавить curl-пример для POST /users в README.md
- [ ] Добавить endpoint в OpenAPI/Swagger
- [ ] Написать unit-тест: успешное создание пользователя
- [ ] Написать unit-тест: дублирование пользователя (409)

- [ ] Описать схему ответа для GET /users
- [ ] Реализовать GET /users (пагинация, фильтрация)
- [ ] Добавить логирование запроса списка пользователей
- [ ] Добавить curl-пример для GET /users в README.md
- [ ] Добавить endpoint в OpenAPI/Swagger
- [ ] Написать unit-тест: пустой список
- [ ] Написать unit-тест: непустой список

- [ ] Описать схему ответа для GET /users/{user_id}
- [ ] Реализовать GET /users/{user_id} (404 если не найден)
- [ ] Добавить логирование запроса пользователя
- [ ] Добавить curl-пример для GET /users/{user_id} в README.md
- [ ] Добавить endpoint в OpenAPI/Swagger
- [ ] Написать unit-тест: найден
- [ ] Написать unit-тест: не найден (404)

- [ ] Описать схему запроса/ответа для PATCH /users/{user_id}
- [ ] Реализовать PATCH /users/{user_id} (валидация, логирование изменений)
- [ ] Добавить curl-пример для PATCH /users/{user_id} в README.md
- [ ] Добавить endpoint в OpenAPI/Swagger
- [ ] Написать unit-тест: успешное обновление
- [ ] Написать unit-тест: не найден (404)

- [ ] Реализовать DELETE /users/{user_id} (404 если не найден, логирование)
- [ ] Добавить curl-пример для DELETE /users/{user_id} в README.md
- [ ] Добавить endpoint в OpenAPI/Swagger
- [ ] Написать unit-тест: успешное удаление
- [ ] Написать unit-тест: не найден (404)

#### 4. CRUD endpoints (Agent, Scenario) — аналогично User

#### 5. Endpoint запуска сценария
- [ ] Описать схему запроса для POST /agents/{agent_id}/run
- [ ] Реализовать базовый запуск сценария (state machine: шаги по очереди)
- [ ] Логировать каждый шаг сценария (logs/api.log)
- [ ] Обрабатывать ошибки сценария (fallback, лог ошибок)
- [ ] Добавить curl-пример для запуска сценария в README.md
- [ ] Добавить endpoint в OpenAPI/Swagger
- [ ] Написать интеграционный тест: успешный запуск
- [ ] Написать интеграционный тест: ошибка сценария

#### 6. Интеграции (mock)
- [ ] Описать схему запроса/ответа для POST /llm/query
- [ ] Реализовать endpoint (принимать prompt, возвращать заглушку)
- [ ] Добавить curl-пример для POST /llm/query в README.md
- [ ] Добавить endpoint в OpenAPI/Swagger
- [ ] Написать интеграционный тест: успешный запрос

- [ ] Аналогично для POST /crm/mock и POST /rag/mock
- [ ] Реализовать circuit breaker для внешних интеграций (LLM, CRM, RAG)
- [ ] Реализовать fallback-ответы при недоступности внешних сервисов
- [ ] Добавить алерты и логирование при сбоях интеграций (logs/integration_errors.log)

#### 7. Healthcheck и OpenAPI
- [ ] Реализовать GET /health (возвращать статус сервисов)
- [ ] Добавить curl-пример для GET /health в README.md
- [ ] Проверить автогенерацию Swagger
- [ ] Написать unit-тест: сервис жив

#### 8. Логирование
- [ ] Настроить loguru/logging на запись в logs/api.log (JSON)
- [ ] Добавить логирование ошибок в logs/errors.log
- [ ] Проверить запись логов при ошибках и успешных операциях

#### 9. Очереди и масштабирование
- [ ] Настроить мониторинг очередей задач (Flower или custom dashboard)
- [ ] Реализовать обработку зависших задач (dead letter queue)
- [ ] Реализовать автоматический рестарт воркеров при сбоях
- [ ] Добавить алерты при переполнении очередей или сбоях воркеров

#### 10. Безопасность и права доступа
- [ ] Реализовать rate limiting для всех публичных endpoint'ов
- [ ] Реализовать логирование подозрительных активностей (logs/security.log)
- [ ] Провести тестирование на проникновение (OWASP Top 10)
- [ ] Добавить unit- и интеграционные тесты на безопасность (авторизация, права, rate limiting)
- [ ] Включить автоматическую проверку на утечки секретов (git-secrets, trufflehog)
- [ ] Настроить безопасное хранение секретов (.env в gitignore, Vault и др.)
- [ ] Включить автоматическую ротацию секретов

---

### Frontend (Next.js, Ant Design, BPMN.js) — микрозадачи

#### 1. Базовая структура
- [ ] Сгенерировать проект create-next-app
- [ ] Подключить Ant Design/MUI
- [ ] Настроить базовую структуру страниц (routes)
- [ ] Включить автоматическую проверку зависимостей (npm audit, Snyk)
- [ ] Включить автоматическую проверку стиля и форматирования (pre-commit, pre-push)

#### 2. Аутентификация (заглушка)
- [ ] Реализовать компонент LoginForm (валидация, mock-логин)
- [ ] Добавить хранение токена (localStorage, context)
- [ ] Покрыть unit-тестом: успешный логин, неуспешный логин

#### 3. UI для агентов
- [ ] Реализовать компонент AgentCard (props: name, status, actions)
- [ ] Покрыть unit-тестом: отображение агента
- [ ] Реализовать страницу /agents (GET /agents, отображение списка)
- [ ] Покрыть unit-тестом: пустой и непустой список
- [ ] Реализовать страницу /agents/new (форма создания, POST /agents)
- [ ] Покрыть unit-тестом: успешное создание, ошибка
- [ ] Реализовать страницу /agents/[id] (форма редактирования, PATCH /agents/{id})
- [ ] Покрыть unit-тестом: успешное обновление, ошибка

#### 4. UI для сценариев
- [ ] Реализовать компонент ScenarioCard
- [ ] Покрыть unit-тестом: отображение сценария
- [ ] Реализовать страницу /scenarios (GET /scenarios)
- [ ] Покрыть unit-тестом: пустой и непустой список
- [ ] Реализовать страницу /scenarios/new (POST /scenarios)
- [ ] Покрыть unit-тестом: успешное создание, ошибка
- [ ] Реализовать страницу /scenarios/[id] (PATCH /scenarios/{id})
- [ ] Покрыть unit-тестом: успешное обновление, ошибка

#### 5. BPMN-редактор
- [ ] Подключить BPMN.js
- [ ] Реализовать компонент BPMNEditor (минимальный drag-and-drop)
- [ ] Покрыть unit-тестом: добавление/удаление шага
- [ ] Сохранение схемы в формате JSON/BPMN
- [ ] Покрыть unit-тестом: сохранение схемы

#### 6. Просмотр логов
- [ ] Реализовать страницу /logs (GET /logs, отображение последних записей)
- [ ] Покрыть unit-тестом: отображение логов

#### 7. Failover и мультиканальность
- [ ] Реализовать E2E-тесты для сценариев с переключением каналов (web ↔ Telegram ↔ email)
- [ ] Реализовать обработку ошибок и восстановление после сбоев канала (failover)
- [ ] Добавить алерты при сбоях каналов

---

### Интеграции и плагины — микрозадачи

- [ ] Описать PluginBase (методы: on_event, healthcheck)
- [ ] Покрыть unit-тестом: инициализация плагина
- [ ] Реализовать регистрацию плагинов (app/plugins/__init__.py)
- [ ] Покрыть unit-тестом: регистрация плагина
- [ ] Реализовать mock-LLM plugin (метод on_event возвращает заглушку)
- [ ] Покрыть unit-тестом: вызов on_event
- [ ] Реализовать mock-CRM plugin
- [ ] Реализовать mock-RAG plugin
- [ ] Добавить пример использования (docs/examples/plugin_example.py)
- [ ] Покрыть unit-тестами (tests/plugins/)
- [ ] Реализовать fallback-логику в плагинах при ошибках внешних сервисов
- [ ] Добавить unit-тесты на отказоустойчивость плагинов

---

### Тесты — микрозадачи

- [ ] Написать unit-тест для POST /users (валидный и невалидный запрос)
- [ ] Написать unit-тест для GET /users (пустой и непустой список)
- [ ] Написать unit-тест для PATCH /users/{user_id} (успех и 404)
- [ ] Написать unit-тест для DELETE /users/{user_id} (успех и 404)
- [ ] Аналогично для Agent и Scenario
- [ ] Интеграционный тест: запуск сценария (POST /agents/{agent_id}/run)
- [ ] Интеграционный тесты для mock-интеграций
- [ ] E2E-тест: полный пользовательский путь (создание пользователя → запуск сценария)
- [ ] Проверить запись логов тестов в logs/unit_tests.log
- [ ] E2E-тест: сценарий с отказом внешнего сервиса и проверкой fallback-ответа
- [ ] E2E-тест: сценарий с переполнением очереди и восстановлением
- [ ] E2E-тест: сценарий с переключением каналов (failover)
- [ ] Интеграционный тест: rate limiting (превышение лимита)
- [ ] Интеграционный тест: circuit breaker (блокировка при частых ошибках)

---

### Документация — микрозадачи

- [ ] Добавить curl-пример для каждого endpoint в README.md
- [ ] Описать структуру сценария (docs/scenario_format.md)
- [ ] Добавить пример сценария (docs/examples/scenario_example.json)
- [ ] Добавить пример плагина (docs/examples/plugin_example.py)
- [ ] Описать процесс запуска (docker-compose up, .env)
- [ ] Добавить FAQ и troubleshooting (docs/faq.md)
- [ ] Добавить гайд по созданию сценария (docs/howto_create_scenario.md)
- [ ] Добавить гайд по интеграции нового плагина (docs/howto_plugin.md)
- [ ] Реализовать автоматическую валидацию актуальности OpenAPI/Swagger и README.md (скрипт сравнения)
- [ ] Добавить раздел "Отказоустойчивость и best practices" в документацию (docs/fault_tolerance.md)

---

### CI/CD — микрозадачи

- [ ] Настроить pre-commit для black, isort, flake8
- [ ] Настроить pre-commit для eslint, prettier
- [ ] Настроить pytest, coverage
- [ ] Настроить unit/integration тесты для frontend
- [ ] Сборка Docker-образа backend
- [ ] Сборка Docker-образа frontend
- [ ] Деплой в docker-compose
- [ ] Проверка логов и healthcheck после деплоя
- [ ] Генерация отчёта о покрытии тестами
- [ ] Автоматизация публикации документации (mkdocs, github pages)

---

**Этот план позволяет быстро получить рабочую платформу, которую легко расширять и адаптировать под любые задачи — от простых опросов до сложных мультиагентных систем.** 

---

## Риски и стратегии их минимизации

### 1. Архитектура и интеграции
- **Риск:** Сложности с управлением зависимостями и версионированием API в микросервисной архитектуре.
  - **Стратегия:** Внедрить централизованный API Gateway, использовать OpenAPI-спеки, автоматизировать тесты совместимости.
- **Риск:** Уязвимости и нестабильность при подключении сторонних плагинов.
  - **Стратегия:** Использовать sandbox-окружение для плагинов, ограничивать права, внедрить аудит и валидацию плагинов.
- **Риск:** Сложности интеграции Flowise/BPMN.js с кастомными сценариями.
  - **Стратегия:** Разработать адаптеры и тестовые сценарии для проверки совместимости.

### 2. Хранение и синхронизация данных
- **Риск:** Конфликты данных и race conditions при асинхронной синхронизации с общей БД.
  - **Стратегия:** Использовать версионирование записей, реализовать стратегию разрешения конфликтов (last write wins, merge, manual review).

### 3. Логирование и мониторинг
- **Риск:** Быстрый рост объёма логов, нагрузка на систему логирования.
  - **Стратегия:** Внедрить ротацию, агрегацию, автоматическую очистку логов, хранить только необходимые уровни логов в production.

### 4. Безопасность
- **Риск:** Ошибки в реализации RBAC, 2FA, SSO могут привести к эскалации прав или утечке данных.
  - **Стратегия:** Проводить регулярные security review, использовать готовые решения (например, Keycloak), автоматизировать тесты на права доступа.
- **Риск:** Уязвимости при работе с внешними интеграциями и плагинами.
  - **Стратегия:** Ограничивать сетевые и файловые права плагинов, внедрять мониторинг подозрительных действий.

### 5. Тестирование и CI/CD
- **Риск:** Недостаточное покрытие тестами или сложность поддержки e2e-тестов для мультиканальности.
  - **Стратегия:** Автоматизировать генерацию тестов, использовать mock-сервисы для внешних интеграций, внедрить регулярный аудит покрытия.

### 6. Документация и поддержка
- **Риск:** Несвоевременное обновление документации, расхождение с фактической реализацией.
  - **Стратегия:** Автоматизировать генерацию документации (Swagger, mkdocs), внедрить pre-commit хуки на обновление README и OpenAPI.

### 7. Масштабирование и производительность
- **Риск:** Нехватка ресурсов при росте нагрузки, деградация производительности очередей и сервисов.
  - **Стратегия:** Использовать горизонтальное масштабирование (k8s HPA), внедрить мониторинг метрик и алерты, проводить нагрузочное тестирование.

---

### Гибкость и расширяемость схемы
- Все новые поля в моделях должны быть Optional (опциональными)
- В Pydantic-моделях использовать `extra = "allow"` для поддержки дополнительных полей
- Для сложных изменений схемы использовать поле `schema_version` и миграционные скрипты
- При добавлении новых полей не требуется миграция старых данных, если они опциональны

---

### Тестирование (подход и ограничения)
- **Обязательный smoke-тест:** только создание пользователя (test_create_user) — всегда должен проходить, проверяет связку FastAPI + Motor + MongoDB.
- **Остальные e2e-тесты (get, delete и т.д.)** с Motor и TestClient нестабильны из-за архитектурных ограничений (event loop is closed). Их запускать вручную или помечать как xfail/skipped.
- **Для бизнес-логики**: использовать unit-тесты с моками репозитория (UserRepository), не трогая реальную базу.
- **Для CI/CD:** запускать только smoke-тест (создание пользователя).
- **Перед каждым тестом** очищать тестовые данные через pymongo, чтобы избежать конфликтов по email.
- **Преобразование ObjectId:** всегда приводить _id к строке в репозитории, чтобы избежать ошибок сериализации Pydantic.
- **Документация:** зафиксировать этот подход, чтобы не тратить время на борьбу с event loop и асинхронностью в e2e.

---

- [x] Минимальный smoke-тест (создание пользователя)
- [x] Очистка тестовых данных перед тестом
- [x] Исправление ObjectId → str в репозитории
- [ ] Моки для unit-тестов бизнес-логики
- [ ] Документировать ограничения e2e-тестов с Motor
- [ ] Продолжить разработку API/логики

---

## Статус RAG (Retrieval-Augmented Generation)
- [x] Локальные эмбеддинги через SentenceTransformers
- [x] Генерация ответа через OpenRouter (google/gemma-3-27b-it:free)
- [x] Исправлен FAISS (allow_dangerous_deserialization)
- [x] Исправлен healthcheck, endpoint /integration/rag/query готов
- [x] Добавлены все зависимости в requirements.txt
- [ ] Пересборка контейнера с новыми зависимостями (в процессе)
- [ ] Проверить генерацию ответа после сборки
- [ ] После успешного теста — можно переходить к интеграции с фронтом и e2e

---

## Интеграция с Telegram (архитектура и задачи)
- [ ] Универсальный Telegram-плагин (Bot API + Userbot)
- [ ] Поддержка webhook и polling (выбор через конфиг)
- [ ] Поддержка нескольких ботов (мульти-токен)
- [ ] Userbot (pyrogram, Telethon не использовать)
- [ ] Обработка команд, кнопок, inline/reply меню
- [ ] Интеграция с каналами (рассылки, постинг, админ-функции)
- [ ] Обработка событий (join, leave, callback, реакции и т.д.)
- [ ] Логирование всех событий (logs/integration.log, logs/events.log)
- [ ] Плагин-интерфейс для расширения логики (RAG, CRM, сценарии)
- [ ] Примеры сценариев: чат-бот, рассылка, интеграция с RAG
- [ ] Документация и curl-примеры для API управления ботами