"""
üîç VectorSearchTool - –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∏ RAG —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª

–ü–µ—Ä–≤—ã–π –∫—Ä–∏—Ç–∏—á–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –∫–æ–Ω–∫—É—Ä–µ–Ω—Ü–∏–∏ —Å OpenAI/Claude.
–ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –≤–µ–∫—Ç–æ—Ä–Ω—ã–π –ø–æ–∏—Å–∫, –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏ RAG.
"""

import os
import asyncio
from typing import List, Dict, Optional, Any, Union
from pathlib import Path
import tempfile
import hashlib
from dataclasses import dataclass

try:
    import chromadb
    from chromadb.config import Settings
    from sentence_transformers import SentenceTransformer
    VECTOR_DEPS_AVAILABLE = True
except ImportError:
    VECTOR_DEPS_AVAILABLE = False

from .base_tool import Tool, ToolResult
from .unified_tool_result import ToolResult


@dataclass
class Document:
    """–î–æ–∫—É–º–µ–Ω—Ç –¥–ª—è –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞"""
    content: str
    metadata: Dict[str, Any]
    id: Optional[str] = None
    score: Optional[float] = None


@dataclass
class SearchMatch:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–∏—Å–∫–∞"""
    document: Document
    score: float
    rank: int


class VectorSearchTool(Tool):
    """
    üîç –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∏ RAG —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª
    
    –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
    - –°–æ–∑–¥–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–Ω—ã—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π
    - –ò–Ω–¥–µ–∫—Å–∞—Ü–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ —Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏  
    - –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫
    - RAG pipeline –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
    """
    
    def __init__(self, 
                 storage_path: Optional[str] = None,
                 embedding_model: str = "all-MiniLM-L6-v2",
                 collection_name: str = "kittycore_default"):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è VectorSearchTool
        
        Args:
            storage_path: –ü—É—Ç—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–Ω–æ–π –ë–î
            embedding_model: –ú–æ–¥–µ–ª—å —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ 
            collection_name: –ò–º—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        """
        super().__init__(
            name="vector_search",
            description="–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∏ RAG —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª"  
        )
        
        if not VECTOR_DEPS_AVAILABLE:
            raise ImportError(
                "–í–µ–∫—Ç–æ—Ä–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã. –í—ã–ø–æ–ª–Ω–∏—Ç–µ:\n"
                "pip install chromadb sentence-transformers"
            )
        
        self.storage_path = storage_path or os.path.join(tempfile.gettempdir(), "kittycore_vectors")
        self.embedding_model_name = embedding_model
        self.default_collection = collection_name
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ChromaDB
        self._init_chroma()
        self._init_embedding_model()
        
    def _init_chroma(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ChromaDB –∫–ª–∏–µ–Ω—Ç–∞"""
        try:
            os.makedirs(self.storage_path, exist_ok=True)
            
            self.chroma_client = chromadb.PersistentClient(
                path=self.storage_path,
                settings=Settings(
                    anonymized_telemetry=False,
                    allow_reset=True
                )
            )
            
            print(f"ChromaDB –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω: {self.storage_path}")
            
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ ChromaDB: {e}")
            raise
    
    def _init_embedding_model(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–¥–µ–ª–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤"""
        try:
            self.embedding_model = SentenceTransformer(self.embedding_model_name)
            print(f"–ú–æ–¥–µ–ª—å —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤ –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {self.embedding_model_name}")
            
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏ —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤: {e}")
            raise
    
    def get_available_actions(self) -> List[str]:
        """–î–æ—Å—Ç—É–ø–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è"""
        return [
            "search_documents",
            "add_documents", 
            "create_collection",
            "list_collections",
            "delete_collection",
            "get_collection_stats",
            "similarity_search",
            "hybrid_search"
        ]
    
    async def search_documents(self, 
                             query: str, 
                             collection_name: Optional[str] = None,
                             top_k: int = 5,
                             filter_metadata: Optional[Dict] = None) -> ToolResult:
        """
        –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
        
        Args:
            query: –ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
            collection_name: –ò–º—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏ 
            top_k: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            filter_metadata: –§–∏–ª—å—Ç—Ä –ø–æ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º
        """
        try:
            collection_name = collection_name or self.default_collection
            
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–ª–µ–∫—Ü–∏—é
            collection = self.chroma_client.get_collection(collection_name)
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —ç–º–±–µ–¥–¥–∏–Ω–≥ –∑–∞–ø—Ä–æ—Å–∞
            query_embedding = self.embedding_model.encode([query]).tolist()[0]
            
            # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫
            results = collection.query(
                query_embeddings=[query_embedding],
                n_results=top_k,
                where=filter_metadata
            )
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            matches = []
            if results['documents'][0]:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –µ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                for i, (doc, metadata, distance, doc_id) in enumerate(zip(
                    results['documents'][0],
                    results['metadatas'][0],
                    results['distances'][0],
                    results['ids'][0]
                )):
                    score = 1.0 - distance  # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º distance –≤ score
                    document = Document(
                        content=doc,
                        metadata=metadata or {},
                        id=doc_id,
                        score=score
                    )
                    matches.append(SearchMatch(document=document, score=score, rank=i+1))
            
            result_data = {
                "query": query,
                "collection": collection_name,
                "total_matches": len(matches),
                "matches": [
                    {
                        "rank": match.rank,
                        "score": round(match.score, 4),
                        "content": match.document.content,
                        "metadata": match.document.metadata,
                        "id": match.document.id
                    }
                    for match in matches
                ]
            }
            
            return ToolResult(
                success=True,
                data=result_data)
            
        except Exception as e:
            return ToolResult(
                success=False,
                error=str(e))
    
    async def add_documents(self,
                          documents: List[str],
                          metadatas: Optional[List[Dict]] = None,
                          ids: Optional[List[str]] = None,
                          collection_name: Optional[str] = None) -> ToolResult:
        """
        –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ –≤–µ–∫—Ç–æ—Ä–Ω—É—é –±–∞–∑—É
        
        Args:
            documents: –°–ø–∏—Å–æ–∫ —Ç–µ–∫—Å—Ç–æ–≤ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
            metadatas: –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞
            ids: ID –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ)
            collection_name: –ò–º—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏
        """
        try:
            collection_name = collection_name or self.default_collection
            
            # –°–æ–∑–¥–∞—ë–º –∫–æ–ª–ª–µ–∫—Ü–∏—é –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            await self.create_collection(collection_name)
            
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–ª–µ–∫—Ü–∏—é
            collection = self.chroma_client.get_collection(collection_name)
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º ID –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã
            if ids is None:
                ids = [
                    hashlib.md5(doc.encode()).hexdigest()
                    for doc in documents
                ]
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            if metadatas is None:
                metadatas = [{"source": "kittycore"} for _ in documents]
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —ç–º–±–µ–¥–¥–∏–Ω–≥–∏
            embeddings = self.embedding_model.encode(documents).tolist()
            
            # –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—é
            collection.add(
                documents=documents,
                embeddings=embeddings,
                metadatas=metadatas,
                ids=ids
            )
            
            result_data = {
                "collection": collection_name,
                "added_count": len(documents),
                "document_ids": ids,
                "embedding_model": self.embedding_model_name
            }
            
            return ToolResult(
                success=True,
                data=result_data)
            
        except Exception as e:
            return ToolResult(
                success=False,
                error=str(e))
    
    async def create_collection(self, 
                              collection_name: str,
                              metadata: Optional[Dict] = None) -> ToolResult:
        """
        –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–æ–ª–ª–µ–∫—Ü–∏–∏
        
        Args:
            collection_name: –ò–º—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏
            metadata: –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
        """
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
            try:
                existing = self.chroma_client.get_collection(collection_name)
                return ToolResult(
                    success=True,
                    data={"collection": collection_name, "status": "already_exists"})
            except:
                pass  # –ö–æ–ª–ª–µ–∫—Ü–∏—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Å–æ–∑–¥–∞—ë–º
            
            # –°–æ–∑–¥–∞—ë–º –∫–æ–ª–ª–µ–∫—Ü–∏—é
            collection = self.chroma_client.create_collection(
                name=collection_name,
                metadata=metadata or {"created_by": "kittycore", "model": self.embedding_model_name}
            )
            
            result_data = {
                "collection": collection_name,
                "status": "created",
                "metadata": metadata,
                "embedding_model": self.embedding_model_name
            }
            
            return ToolResult(
                success=True,
                data=result_data)
            
        except Exception as e:
            return ToolResult(
                success=False,
                error=str(e))
    
    async def list_collections(self) -> ToolResult:
        """–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π"""
        try:
            collections = self.chroma_client.list_collections()
            
            collection_info = []
            for collection in collections:
                try:
                    count = collection.count()
                    collection_info.append({
                        "name": collection.name,
                        "count": count,
                        "metadata": collection.metadata
                    })
                except:
                    collection_info.append({
                        "name": collection.name,
                        "count": 0,
                        "metadata": {}
                    })
            
            return ToolResult(
                success=True,
                data={"collections": collection_info, "total": len(collection_info)})
            
        except Exception as e:
            return ToolResult(
                success=False,
                error=str(e))
    
    async def get_collection_stats(self, collection_name: str) -> ToolResult:
        """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ–ª–ª–µ–∫—Ü–∏–∏"""
        try:
            collection = self.chroma_client.get_collection(collection_name)
            
            stats = {
                "name": collection_name,
                "document_count": collection.count(),
                "metadata": collection.metadata,
                "embedding_model": self.embedding_model_name,
                "storage_path": self.storage_path
            }
            
            return ToolResult(
                success=True,
                data=stats)
            
        except Exception as e:
            return ToolResult(
                success=False,
                error=str(e))
    
    def execute(self, **kwargs) -> ToolResult:
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±—ë—Ä—Ç–∫–∞ –¥–ª—è execute_action"""
        action = kwargs.pop('action', 'search_documents')  # –ò—Å–ø–æ–ª—å–∑—É–µ–º pop —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å –∏–∑ kwargs
        return asyncio.run(self.execute_action(action, **kwargs))
    
    def get_schema(self) -> Dict[str, Any]:
        """JSON Schema –¥–ª—è VectorSearchTool"""
        return {
            "type": "object",
            "properties": {
                "action": {
                    "type": "string",
                    "enum": self.get_available_actions(),
                    "description": "–î–µ–π—Å—Ç–≤–∏–µ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è"
                },
                "query": {
                    "type": "string", 
                    "description": "–ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å"
                },
                "collection_name": {
                    "type": "string",
                    "description": "–ò–º—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏"
                },
                "top_k": {
                    "type": "integer",
                    "default": 5,
                    "description": "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"
                },
                "documents": {
                    "type": "array",
                    "items": {"type": "string"},
                    "description": "–°–ø–∏—Å–æ–∫ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è"
                },
                "metadatas": {
                    "type": "array",
                    "items": {"type": "object"},
                    "description": "–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"
                }
            },
            "required": ["action"]
        }
    
    async def execute_action(self, action: str, **kwargs) -> ToolResult:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞"""
        if action == "search_documents":
            return await self.search_documents(**kwargs)
        elif action == "add_documents":
            return await self.add_documents(**kwargs)
        elif action == "create_collection":
            return await self.create_collection(**kwargs)
        elif action == "list_collections":
            return await self.list_collections()
        elif action == "get_collection_stats":
            return await self.get_collection_stats(**kwargs)
        else:
            return ToolResult(
                success=False,
                error=f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ: {action}")
    
    def __str__(self) -> str:
        return f"VectorSearchTool(model={self.embedding_model_name}, storage={self.storage_path})"