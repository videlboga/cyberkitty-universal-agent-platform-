# Формат сценария Universal Agent Platform

Сценарий — это JSON-объект (или YAML, который будет преобразован в JSON) с основными полями:
- `name` (строка): Название сценария, информативно для пользователя и логов.
- `description` (строка, опционально): Более подробное описание сценария.
- `version` (строка, опционально): Версия сценария, например, "1.0".
- `initial_context` (объект, опционально): Словарь с начальными значениями переменных, которые будут доступны в контексте сценария с самого начала.
- `steps` (массив, обязательно): Список шагов сценария. Каждый шаг — это объект, описывающий определенное действие или логику.

## Общая структура шага и использование `params`

Каждый шаг в сценарии имеет базовые поля, такие как `id` (опционально, но рекомендуется для наглядности и управления потоком), `type` (обязательно) и поля для управления потоком (`next_step`, `condition`, `branches`).

Большинство параметров, специфичных для конкретного типа шага (например, текст сообщения, код для выполнения, ID под-сценария), должны находиться внутри вложенного объекта `params`. Это помогает структурировать данные шага и отделять общую конфигурацию потока от деталей выполнения самого шага.

**Пример базовой структуры шага:**
```json
{
  "id": "step_1_greet",
  "type": "message",
  "params": {
    "text": "Привет, {user_name}!"
  },
  "next_step": "step_2_ask_question"
}
```

**Важно:**
- Поля `type`, `id`, `next_step`, `condition`, `branches` обычно находятся на верхнем уровне объекта шага.
- Остальные параметры, определяющие поведение шага, как правило, помещаются в `params`. Обработчик каждого типа шага ожидает свои параметры именно в `params`.

## Переменные и `context`

- В каждом шаге доступен объект `context` (словарь Python), который накапливает все данные по ходу выполнения сценария (ввод пользователя, результаты операций, переменные из `initial_context` и т.д.).
- Система поддерживает автоматическую подстановку значений из текущего `context` в строковые параметры шагов. Это позволяет создавать динамические сценарии.
- Используйте синтаксис `{placeholder_name}` для подстановки.
- Поддерживается доступ к вложенным объектам и элементам списка: `{user.profile.name}`, `{results[0].text}`.
- Разрешение происходит для всех строковых значений внутри объекта `params` и для других релевантных полей (например, `condition` в шаге `branch`).

**Пример использования контекста:**
Если `context` содержит `{"user_name": "Алиса", "order_details": {"item": "книга", "count": 2}}`, то шаг:
```json
{
  "type": "message",
  "params": {
    "text": "Заказ для {user_name}: {order_details.item} (x{order_details.count})."
  }
}
```
сгенерирует сообщение: "Заказ для Алисы: книга (x2)."

## Ключевые поля объекта шага

Каждый объект в массиве `steps` может содержать следующие поля:

- `id` (строка, опционально): Уникальный идентификатор шага в рамках сценария. Рекомендуется для явных переходов (`next_step`) и для отладки.
- `type` (строка, обязательно): Тип шага, определяющий его логику (например, `message`, `input`, `branch`, `action`, `execute_sub_scenario`, `llm_request` и т.д.).
- `params` (объект, опционально): Словарь, содержащий параметры, специфичные для данного `type` шага. Большинство настроек шага размещаются здесь.
- `next_step` (строка, опционально): `id` следующего шага, к которому нужно перейти после выполнения текущего. Если не указан, и нет других условий перехода (например, в `branch`), сценарий может завершиться или перейти к следующему шагу по порядку в массиве `steps` (поведение по умолчанию зависит от реализации state machine, но явное указание `next_step` или использование `branch` предпочтительнее).
- `condition` (строка, опционально, используется с `type: "branch"`): Python-выражение, которое вычисляется для определения ветвления. Должно возвращать `True` или `False`. Имеет доступ к `context`.
- `branches` (объект, опционально, используется с `type: "branch"`): Словарь, определяющий переходы для ветвления. Обычно содержит ключи `"if"` и `"else"`, значения которых – `id` шагов для перехода (например, `{"if": "step_id_if_true", "else": "step_id_if_false"}`).

**Дополнительные поля:** Модель данных для шага может допускать и другие поля (`extra = "allow"`), но выше перечислены основные, используемые исполнителем сценариев.

## Основные типы шагов

### `message`
Отображает сообщение.
```json
{
  "id": "welcome_msg",
  "type": "message",
  "params": {
    "text": "Добро пожаловать, {user_name}!"
  },
  "next_step": "main_menu"
}
```

### `input`
Ожидает ввод от пользователя (логика ввода реализуется на стороне клиента/интерфейса). Исполнитель сценариев обычно просто фиксирует этот шаг и ожидает внешнего события для продолжения.
```json
{
  "id": "ask_age",
  "type": "input",
  "params": {
    "prompt": "Сколько вам лет?",
    "input_variable": "user_age" // Имя переменной в context для сохранения ввода
  },
  "next_step": "age_check"
}
```
*Примечание: фактическое сохранение в `input_variable` может потребовать дополнительной логики или шага `action` в зависимости от реализации интеграции с системой ввода.*

### `branch`
Ветвление на основе условия.
```json
{
  "id": "age_check",
  "type": "branch",
  "condition": "context.get('user_age', 0) >= 18",
  "branches": {
    "if": "adult_content",
    "else": "child_content"
  },
  "params": { 
    // params для branch обычно не используются, condition и branches на верхнем уровне
    "description": "Проверка совершеннолетия пользователя" 
  }
}
```
- Если условие истинно — переход к шагу с `id`, указанным в `branches.if`.
- Иначе — переход к шагу с `id`, указанным в `branches.else`.

### `execute_sub_scenario`
Выполнение под-сценария.
Этот тип шага позволяет запускать другой сценарий (под-сценарий) из текущего.

**Параметры (внутри `params`):**
- `sub_scenario_id` (обязательный): Строковый идентификатор (ID из БД) сценария, который нужно запустить.
- `input_parameters` (опциональный): Словарь, ключи и значения которого будут добавлены или перезаписаны в начальном контексте под-сценария. Значения в `input_parameters` могут содержать плейсхолдеры, которые разрешаются из контекста родительского сценария.
- `output_mapping` (опциональный): Определяет, как финальный контекст под-сценария будет передан обратно в контекст родительского сценария.
    - Если `output_mapping` – это словарь (например, `{"parent_key": "{sub_context_key}", "another_parent_key": "fixed_value_or_sub_key"}`): Ключи словаря – это ключи в родительском контексте, а значения – это ключи (или плейсхолдеры, разрешаемые из контекста *под-сценария*) из финального контекста под-сценария.
    - Если `output_mapping` – это список строк (например, `["key1_from_sub", "key2_from_sub"]`): Только указанные ключи из финального контекста под-сценария будут скопированы в родительский контекст с теми же именами.
    - Если `output_mapping` не указан: **Внимание!** Весь финальный контекст под-сценария будет объединен с контекстом родительского сценария, что может привести к перезаписи существующих переменных в родительском контексте. Рекомендуется всегда использовать явный `output_mapping`.

**Пример:**
```json
{
  "id": "run_user_validation",
  "type": "execute_sub_scenario",
  "params": {
    "sub_scenario_id": "user_validation_flow",
    "input_parameters": {
      "user_id_to_validate": "{current_user.id}",
      "validation_level": "strict"
    },
    "output_mapping": {
      "is_user_valid": "{validation_result.isValid}",
      "user_validation_details": "{validation_result.details}"
    }
  },
  "next_step": "proceed_if_valid"
}
```

### `action`
Шаг `action` предназначен для выполнения предопределенных действий, часто связанных с плагинами или базовыми операциями системы. Конкретное действие определяется параметром `action_type` внутри `params`.

#### `action_type: "update_context"`
Это действие позволяет изменять или добавлять переменные в текущий контекст сценария.

**Параметры (внутри `params` для шага `action`):**
- `action_type` (обязательный): Должен быть `"update_context"`.
- `updates` (обязательный): Словарь, где ключи – это имена переменных в контексте, а значения – их новые значения. Значения могут содержать плейсхолдеры, которые разрешаются из текущего контекста *перед* обновлением.

**Пример:**
```json
{
  "id": "set_initial_score",
  "type": "action",
  "params": {
    "action_type": "update_context",
    "updates": {
      "score": 0,
      "level": "{default_level}",
      "status_message": "Начинаем игру с {score} очками."
    }
  },
  "next_step": "game_loop"
}
```

#### Другие `action_type`
Существуют и другие `action_type`, предоставляемые системой и плагинами. Например:
- `telegram_send_message`: для отправки сообщений через Telegram. Параметры (например, `chat_id`, `text`) также передаются внутри `params` основного шага `action`.
- Интеграции с LLM, RAG, хранилищем MongoDB, планировщиком и т.д. обычно реализуются через свои собственные типы шагов (например, `type: "llm_request"`, `type: "rag_search"`, `type: "mongo_insert_one"`, `type: "schedule_scenario_run"`) или через `type: "action"` с соответствующим `action_type`. Обратитесь к документации по конкретным плагинам для деталей.

### `log_message`
Записывает сообщение в лог сервера. Полезно для отладки.
```json
{
  "id": "log_user_choice",
  "type": "log_message",
  "params": {
    "level": "INFO", // DEBUG, INFO, WARNING, ERROR, CRITICAL
    "message": "Пользователь {user_id} выбрал опцию: {user_choice}."
  },
  "next_step": "process_choice"
}
```

### Другие типы шагов
Платформа поддерживает расширение за счет плагинов, которые могут добавлять собственные типы шагов. Примеры:
- `llm_request`: взаимодействие с LLM.
- `rag_search`: поиск по базе знаний (RAG).
- `mongo_find_one`, `mongo_insert_one`, etc.: операции с MongoDB.
- `schedule_scenario_run`: планирование запуска другого сценария.
- `telegram_send_message`, `telegram_send_photo`, etc.: взаимодействие с Telegram.

Для использования этих шагов обратитесь к документации соответствующих плагинов.

## Пример минимального сценария
```json
{
  "name": "Минимальный сценарий",
  "description": "Простой пример для демонстрации.",
  "version": "1.0",
  "initial_context": {
    "guest_name": "Гость"
  },
  "steps": [
    {
      "id": "s1",
      "type": "message",
      "params": {
        "text": "Привет, {guest_name}!"
      },
      "next_step": "s2"
    },
    {
      "id": "s2",
      "type": "message",
      "params": {
        "text": "Пока, {guest_name}!"
      }
    }
  ]
}
```

## Валидация и отладка
- Используйте JSON-валидаторы для проверки синтаксиса.
- Внимательно следите за логами `scenario_executor.log` для отслеживания выполнения шагов и значений контекста.
- Используйте шаг `log_message` для вывода промежуточных значений контекста в лог. 